// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qpstest.proto

#ifndef PROTOBUF_qpstest_2eproto__INCLUDED
#define PROTOBUF_qpstest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace grpc {
namespace testing {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_qpstest_2eproto();
void protobuf_AssignDesc_qpstest_2eproto();
void protobuf_ShutdownFile_qpstest_2eproto();

class StatsRequest;
class ServerStats;
class Payload;
class HistogramData;
class PoissonParams;
class UniformParams;
class DeterministicParams;
class ParetoParams;
class LoadParams;
class ClientConfig;
class Mark;
class ClientArgs;
class ClientStats;
class ClientStatus;
class ServerConfig;
class ServerArgs;
class ServerStatus;
class SimpleRequest;
class SimpleResponse;

enum PayloadType {
  COMPRESSABLE = 0,
  UNCOMPRESSABLE = 1,
  RANDOM = 2,
  PayloadType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PayloadType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PayloadType_IsValid(int value);
const PayloadType PayloadType_MIN = COMPRESSABLE;
const PayloadType PayloadType_MAX = RANDOM;
const int PayloadType_ARRAYSIZE = PayloadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PayloadType_descriptor();
inline const ::std::string& PayloadType_Name(PayloadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PayloadType_descriptor(), value);
}
inline bool PayloadType_Parse(
    const ::std::string& name, PayloadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PayloadType>(
    PayloadType_descriptor(), name, value);
}
enum ClientType {
  SYNCHRONOUS_CLIENT = 0,
  ASYNC_CLIENT = 1,
  ClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = SYNCHRONOUS_CLIENT;
const ClientType ClientType_MAX = ASYNC_CLIENT;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientType_descriptor();
inline const ::std::string& ClientType_Name(ClientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientType_descriptor(), value);
}
inline bool ClientType_Parse(
    const ::std::string& name, ClientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum ServerType {
  SYNCHRONOUS_SERVER = 0,
  ASYNC_SERVER = 1,
  ServerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServerType_IsValid(int value);
const ServerType ServerType_MIN = SYNCHRONOUS_SERVER;
const ServerType ServerType_MAX = ASYNC_SERVER;
const int ServerType_ARRAYSIZE = ServerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerType_descriptor();
inline const ::std::string& ServerType_Name(ServerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerType_descriptor(), value);
}
inline bool ServerType_Parse(
    const ::std::string& name, ServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerType>(
    ServerType_descriptor(), name, value);
}
enum RpcType {
  UNARY = 0,
  STREAMING = 1,
  RpcType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RpcType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RpcType_IsValid(int value);
const RpcType RpcType_MIN = UNARY;
const RpcType RpcType_MAX = STREAMING;
const int RpcType_ARRAYSIZE = RpcType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcType_descriptor();
inline const ::std::string& RpcType_Name(RpcType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcType_descriptor(), value);
}
inline bool RpcType_Parse(
    const ::std::string& name, RpcType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcType>(
    RpcType_descriptor(), name, value);
}
enum LoadType {
  CLOSED_LOOP = 0,
  POISSON = 1,
  UNIFORM = 2,
  DETERMINISTIC = 3,
  PARETO = 4,
  LoadType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoadType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoadType_IsValid(int value);
const LoadType LoadType_MIN = CLOSED_LOOP;
const LoadType LoadType_MAX = PARETO;
const int LoadType_ARRAYSIZE = LoadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoadType_descriptor();
inline const ::std::string& LoadType_Name(LoadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoadType_descriptor(), value);
}
inline bool LoadType_Parse(
    const ::std::string& name, LoadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoadType>(
    LoadType_descriptor(), name, value);
}
// ===================================================================

class StatsRequest : public ::google::protobuf::Message {
 public:
  StatsRequest();
  virtual ~StatsRequest();

  StatsRequest(const StatsRequest& from);

  inline StatsRequest& operator=(const StatsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatsRequest& default_instance();

  void Swap(StatsRequest* other);

  // implements Message ----------------------------------------------

  inline StatsRequest* New() const { return New(NULL); }

  StatsRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatsRequest& from);
  void MergeFrom(const StatsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 test_num = 1;
  void clear_test_num();
  static const int kTestNumFieldNumber = 1;
  ::google::protobuf::int32 test_num() const;
  void set_test_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:grpc.testing.StatsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 test_num_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static StatsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerStats : public ::google::protobuf::Message {
 public:
  ServerStats();
  virtual ~ServerStats();

  ServerStats(const ServerStats& from);

  inline ServerStats& operator=(const ServerStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStats& default_instance();

  void Swap(ServerStats* other);

  // implements Message ----------------------------------------------

  inline ServerStats* New() const { return New(NULL); }

  ServerStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerStats& from);
  void MergeFrom(const ServerStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double time_elapsed = 1;
  void clear_time_elapsed();
  static const int kTimeElapsedFieldNumber = 1;
  double time_elapsed() const;
  void set_time_elapsed(double value);

  // optional double time_user = 2;
  void clear_time_user();
  static const int kTimeUserFieldNumber = 2;
  double time_user() const;
  void set_time_user(double value);

  // optional double time_system = 3;
  void clear_time_system();
  static const int kTimeSystemFieldNumber = 3;
  double time_system() const;
  void set_time_system(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.ServerStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double time_elapsed_;
  double time_user_;
  double time_system_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerStats* default_instance_;
};
// -------------------------------------------------------------------

class Payload : public ::google::protobuf::Message {
 public:
  Payload();
  virtual ~Payload();

  Payload(const Payload& from);

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Payload& default_instance();

  void Swap(Payload* other);

  // implements Message ----------------------------------------------

  inline Payload* New() const { return New(NULL); }

  Payload* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Payload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.PayloadType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::grpc::testing::PayloadType type() const;
  void set_type(::grpc::testing::PayloadType value);

  // optional bytes body = 2;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:grpc.testing.Payload)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static Payload* default_instance_;
};
// -------------------------------------------------------------------

class HistogramData : public ::google::protobuf::Message {
 public:
  HistogramData();
  virtual ~HistogramData();

  HistogramData(const HistogramData& from);

  inline HistogramData& operator=(const HistogramData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistogramData& default_instance();

  void Swap(HistogramData* other);

  // implements Message ----------------------------------------------

  inline HistogramData* New() const { return New(NULL); }

  HistogramData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistogramData& from);
  void MergeFrom(const HistogramData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HistogramData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 bucket = 1;
  int bucket_size() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  ::google::protobuf::uint32 bucket(int index) const;
  void set_bucket(int index, ::google::protobuf::uint32 value);
  void add_bucket(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      bucket() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_bucket();

  // optional double min_seen = 2;
  void clear_min_seen();
  static const int kMinSeenFieldNumber = 2;
  double min_seen() const;
  void set_min_seen(double value);

  // optional double max_seen = 3;
  void clear_max_seen();
  static const int kMaxSeenFieldNumber = 3;
  double max_seen() const;
  void set_max_seen(double value);

  // optional double sum = 4;
  void clear_sum();
  static const int kSumFieldNumber = 4;
  double sum() const;
  void set_sum(double value);

  // optional double sum_of_squares = 5;
  void clear_sum_of_squares();
  static const int kSumOfSquaresFieldNumber = 5;
  double sum_of_squares() const;
  void set_sum_of_squares(double value);

  // optional double count = 6;
  void clear_count();
  static const int kCountFieldNumber = 6;
  double count() const;
  void set_count(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.HistogramData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > bucket_;
  mutable int _bucket_cached_byte_size_;
  double min_seen_;
  double max_seen_;
  double sum_;
  double sum_of_squares_;
  double count_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static HistogramData* default_instance_;
};
// -------------------------------------------------------------------

class PoissonParams : public ::google::protobuf::Message {
 public:
  PoissonParams();
  virtual ~PoissonParams();

  PoissonParams(const PoissonParams& from);

  inline PoissonParams& operator=(const PoissonParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoissonParams& default_instance();

  void Swap(PoissonParams* other);

  // implements Message ----------------------------------------------

  inline PoissonParams* New() const { return New(NULL); }

  PoissonParams* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoissonParams& from);
  void MergeFrom(const PoissonParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PoissonParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double offered_load = 1;
  void clear_offered_load();
  static const int kOfferedLoadFieldNumber = 1;
  double offered_load() const;
  void set_offered_load(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.PoissonParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double offered_load_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static PoissonParams* default_instance_;
};
// -------------------------------------------------------------------

class UniformParams : public ::google::protobuf::Message {
 public:
  UniformParams();
  virtual ~UniformParams();

  UniformParams(const UniformParams& from);

  inline UniformParams& operator=(const UniformParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniformParams& default_instance();

  void Swap(UniformParams* other);

  // implements Message ----------------------------------------------

  inline UniformParams* New() const { return New(NULL); }

  UniformParams* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniformParams& from);
  void MergeFrom(const UniformParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UniformParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double interarrival_lo = 1;
  void clear_interarrival_lo();
  static const int kInterarrivalLoFieldNumber = 1;
  double interarrival_lo() const;
  void set_interarrival_lo(double value);

  // optional double interarrival_hi = 2;
  void clear_interarrival_hi();
  static const int kInterarrivalHiFieldNumber = 2;
  double interarrival_hi() const;
  void set_interarrival_hi(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.UniformParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double interarrival_lo_;
  double interarrival_hi_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static UniformParams* default_instance_;
};
// -------------------------------------------------------------------

class DeterministicParams : public ::google::protobuf::Message {
 public:
  DeterministicParams();
  virtual ~DeterministicParams();

  DeterministicParams(const DeterministicParams& from);

  inline DeterministicParams& operator=(const DeterministicParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeterministicParams& default_instance();

  void Swap(DeterministicParams* other);

  // implements Message ----------------------------------------------

  inline DeterministicParams* New() const { return New(NULL); }

  DeterministicParams* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeterministicParams& from);
  void MergeFrom(const DeterministicParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeterministicParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double offered_load = 1;
  void clear_offered_load();
  static const int kOfferedLoadFieldNumber = 1;
  double offered_load() const;
  void set_offered_load(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.DeterministicParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double offered_load_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static DeterministicParams* default_instance_;
};
// -------------------------------------------------------------------

class ParetoParams : public ::google::protobuf::Message {
 public:
  ParetoParams();
  virtual ~ParetoParams();

  ParetoParams(const ParetoParams& from);

  inline ParetoParams& operator=(const ParetoParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParetoParams& default_instance();

  void Swap(ParetoParams* other);

  // implements Message ----------------------------------------------

  inline ParetoParams* New() const { return New(NULL); }

  ParetoParams* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParetoParams& from);
  void MergeFrom(const ParetoParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ParetoParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double interarrival_base = 1;
  void clear_interarrival_base();
  static const int kInterarrivalBaseFieldNumber = 1;
  double interarrival_base() const;
  void set_interarrival_base(double value);

  // optional double alpha = 2;
  void clear_alpha();
  static const int kAlphaFieldNumber = 2;
  double alpha() const;
  void set_alpha(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.ParetoParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double interarrival_base_;
  double alpha_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ParetoParams* default_instance_;
};
// -------------------------------------------------------------------

class LoadParams : public ::google::protobuf::Message {
 public:
  LoadParams();
  virtual ~LoadParams();

  LoadParams(const LoadParams& from);

  inline LoadParams& operator=(const LoadParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadParams& default_instance();

  enum LoadCase {
    kPoisson = 1,
    kUniform = 2,
    kDeterm = 3,
    kPareto = 4,
    LOAD_NOT_SET = 0,
  };

  void Swap(LoadParams* other);

  // implements Message ----------------------------------------------

  inline LoadParams* New() const { return New(NULL); }

  LoadParams* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadParams& from);
  void MergeFrom(const LoadParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.PoissonParams poisson = 1;
  bool has_poisson() const;
  void clear_poisson();
  static const int kPoissonFieldNumber = 1;
  const ::grpc::testing::PoissonParams& poisson() const;
  ::grpc::testing::PoissonParams* mutable_poisson();
  ::grpc::testing::PoissonParams* release_poisson();
  void set_allocated_poisson(::grpc::testing::PoissonParams* poisson);

  // optional .grpc.testing.UniformParams uniform = 2;
  bool has_uniform() const;
  void clear_uniform();
  static const int kUniformFieldNumber = 2;
  const ::grpc::testing::UniformParams& uniform() const;
  ::grpc::testing::UniformParams* mutable_uniform();
  ::grpc::testing::UniformParams* release_uniform();
  void set_allocated_uniform(::grpc::testing::UniformParams* uniform);

  // optional .grpc.testing.DeterministicParams determ = 3;
  bool has_determ() const;
  void clear_determ();
  static const int kDetermFieldNumber = 3;
  const ::grpc::testing::DeterministicParams& determ() const;
  ::grpc::testing::DeterministicParams* mutable_determ();
  ::grpc::testing::DeterministicParams* release_determ();
  void set_allocated_determ(::grpc::testing::DeterministicParams* determ);

  // optional .grpc.testing.ParetoParams pareto = 4;
  bool has_pareto() const;
  void clear_pareto();
  static const int kParetoFieldNumber = 4;
  const ::grpc::testing::ParetoParams& pareto() const;
  ::grpc::testing::ParetoParams* mutable_pareto();
  ::grpc::testing::ParetoParams* release_pareto();
  void set_allocated_pareto(::grpc::testing::ParetoParams* pareto);

  LoadCase load_case() const;
  // @@protoc_insertion_point(class_scope:grpc.testing.LoadParams)
 private:
  inline void set_has_poisson();
  inline void set_has_uniform();
  inline void set_has_determ();
  inline void set_has_pareto();

  inline bool has_load() const;
  void clear_load();
  inline void clear_has_load();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union LoadUnion {
    LoadUnion() {}
    ::grpc::testing::PoissonParams* poisson_;
    ::grpc::testing::UniformParams* uniform_;
    ::grpc::testing::DeterministicParams* determ_;
    ::grpc::testing::ParetoParams* pareto_;
  } load_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static LoadParams* default_instance_;
};
// -------------------------------------------------------------------

class ClientConfig : public ::google::protobuf::Message {
 public:
  ClientConfig();
  virtual ~ClientConfig();

  ClientConfig(const ClientConfig& from);

  inline ClientConfig& operator=(const ClientConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientConfig& default_instance();

  void Swap(ClientConfig* other);

  // implements Message ----------------------------------------------

  inline ClientConfig* New() const { return New(NULL); }

  ClientConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientConfig& from);
  void MergeFrom(const ClientConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string server_targets = 1;
  int server_targets_size() const;
  void clear_server_targets();
  static const int kServerTargetsFieldNumber = 1;
  const ::std::string& server_targets(int index) const;
  ::std::string* mutable_server_targets(int index);
  void set_server_targets(int index, const ::std::string& value);
  void set_server_targets(int index, const char* value);
  void set_server_targets(int index, const char* value, size_t size);
  ::std::string* add_server_targets();
  void add_server_targets(const ::std::string& value);
  void add_server_targets(const char* value);
  void add_server_targets(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& server_targets() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_server_targets();

  // optional .grpc.testing.ClientType client_type = 2;
  void clear_client_type();
  static const int kClientTypeFieldNumber = 2;
  ::grpc::testing::ClientType client_type() const;
  void set_client_type(::grpc::testing::ClientType value);

  // optional bool enable_ssl = 3;
  void clear_enable_ssl();
  static const int kEnableSslFieldNumber = 3;
  bool enable_ssl() const;
  void set_enable_ssl(bool value);

  // optional int32 outstanding_rpcs_per_channel = 4;
  void clear_outstanding_rpcs_per_channel();
  static const int kOutstandingRpcsPerChannelFieldNumber = 4;
  ::google::protobuf::int32 outstanding_rpcs_per_channel() const;
  void set_outstanding_rpcs_per_channel(::google::protobuf::int32 value);

  // optional int32 client_channels = 5;
  void clear_client_channels();
  static const int kClientChannelsFieldNumber = 5;
  ::google::protobuf::int32 client_channels() const;
  void set_client_channels(::google::protobuf::int32 value);

  // optional int32 payload_size = 6;
  void clear_payload_size();
  static const int kPayloadSizeFieldNumber = 6;
  ::google::protobuf::int32 payload_size() const;
  void set_payload_size(::google::protobuf::int32 value);

  // optional int32 async_client_threads = 7;
  void clear_async_client_threads();
  static const int kAsyncClientThreadsFieldNumber = 7;
  ::google::protobuf::int32 async_client_threads() const;
  void set_async_client_threads(::google::protobuf::int32 value);

  // optional .grpc.testing.RpcType rpc_type = 8;
  void clear_rpc_type();
  static const int kRpcTypeFieldNumber = 8;
  ::grpc::testing::RpcType rpc_type() const;
  void set_rpc_type(::grpc::testing::RpcType value);

  // optional string host = 9;
  void clear_host();
  static const int kHostFieldNumber = 9;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // optional .grpc.testing.LoadType load_type = 10;
  void clear_load_type();
  static const int kLoadTypeFieldNumber = 10;
  ::grpc::testing::LoadType load_type() const;
  void set_load_type(::grpc::testing::LoadType value);

  // optional .grpc.testing.LoadParams load_params = 11;
  bool has_load_params() const;
  void clear_load_params();
  static const int kLoadParamsFieldNumber = 11;
  const ::grpc::testing::LoadParams& load_params() const;
  ::grpc::testing::LoadParams* mutable_load_params();
  ::grpc::testing::LoadParams* release_load_params();
  void set_allocated_load_params(::grpc::testing::LoadParams* load_params);

  // @@protoc_insertion_point(class_scope:grpc.testing.ClientConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> server_targets_;
  int client_type_;
  bool enable_ssl_;
  ::google::protobuf::int32 outstanding_rpcs_per_channel_;
  ::google::protobuf::int32 client_channels_;
  ::google::protobuf::int32 payload_size_;
  ::google::protobuf::int32 async_client_threads_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  int rpc_type_;
  int load_type_;
  ::grpc::testing::LoadParams* load_params_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientConfig* default_instance_;
};
// -------------------------------------------------------------------

class Mark : public ::google::protobuf::Message {
 public:
  Mark();
  virtual ~Mark();

  Mark(const Mark& from);

  inline Mark& operator=(const Mark& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mark& default_instance();

  void Swap(Mark* other);

  // implements Message ----------------------------------------------

  inline Mark* New() const { return New(NULL); }

  Mark* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mark& from);
  void MergeFrom(const Mark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.testing.Mark)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static Mark* default_instance_;
};
// -------------------------------------------------------------------

class ClientArgs : public ::google::protobuf::Message {
 public:
  ClientArgs();
  virtual ~ClientArgs();

  ClientArgs(const ClientArgs& from);

  inline ClientArgs& operator=(const ClientArgs& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientArgs& default_instance();

  enum ArgtypeCase {
    kSetup = 1,
    kMark = 2,
    ARGTYPE_NOT_SET = 0,
  };

  void Swap(ClientArgs* other);

  // implements Message ----------------------------------------------

  inline ClientArgs* New() const { return New(NULL); }

  ClientArgs* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientArgs& from);
  void MergeFrom(const ClientArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ClientConfig setup = 1;
  bool has_setup() const;
  void clear_setup();
  static const int kSetupFieldNumber = 1;
  const ::grpc::testing::ClientConfig& setup() const;
  ::grpc::testing::ClientConfig* mutable_setup();
  ::grpc::testing::ClientConfig* release_setup();
  void set_allocated_setup(::grpc::testing::ClientConfig* setup);

  // optional .grpc.testing.Mark mark = 2;
  bool has_mark() const;
  void clear_mark();
  static const int kMarkFieldNumber = 2;
  const ::grpc::testing::Mark& mark() const;
  ::grpc::testing::Mark* mutable_mark();
  ::grpc::testing::Mark* release_mark();
  void set_allocated_mark(::grpc::testing::Mark* mark);

  ArgtypeCase argtype_case() const;
  // @@protoc_insertion_point(class_scope:grpc.testing.ClientArgs)
 private:
  inline void set_has_setup();
  inline void set_has_mark();

  inline bool has_argtype() const;
  void clear_argtype();
  inline void clear_has_argtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ArgtypeUnion {
    ArgtypeUnion() {}
    ::grpc::testing::ClientConfig* setup_;
    ::grpc::testing::Mark* mark_;
  } argtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientArgs* default_instance_;
};
// -------------------------------------------------------------------

class ClientStats : public ::google::protobuf::Message {
 public:
  ClientStats();
  virtual ~ClientStats();

  ClientStats(const ClientStats& from);

  inline ClientStats& operator=(const ClientStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStats& default_instance();

  void Swap(ClientStats* other);

  // implements Message ----------------------------------------------

  inline ClientStats* New() const { return New(NULL); }

  ClientStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStats& from);
  void MergeFrom(const ClientStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.HistogramData latencies = 1;
  bool has_latencies() const;
  void clear_latencies();
  static const int kLatenciesFieldNumber = 1;
  const ::grpc::testing::HistogramData& latencies() const;
  ::grpc::testing::HistogramData* mutable_latencies();
  ::grpc::testing::HistogramData* release_latencies();
  void set_allocated_latencies(::grpc::testing::HistogramData* latencies);

  // optional double time_elapsed = 2;
  void clear_time_elapsed();
  static const int kTimeElapsedFieldNumber = 2;
  double time_elapsed() const;
  void set_time_elapsed(double value);

  // optional double time_user = 3;
  void clear_time_user();
  static const int kTimeUserFieldNumber = 3;
  double time_user() const;
  void set_time_user(double value);

  // optional double time_system = 4;
  void clear_time_system();
  static const int kTimeSystemFieldNumber = 4;
  double time_system() const;
  void set_time_system(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.ClientStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::grpc::testing::HistogramData* latencies_;
  double time_elapsed_;
  double time_user_;
  double time_system_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientStats* default_instance_;
};
// -------------------------------------------------------------------

class ClientStatus : public ::google::protobuf::Message {
 public:
  ClientStatus();
  virtual ~ClientStatus();

  ClientStatus(const ClientStatus& from);

  inline ClientStatus& operator=(const ClientStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStatus& default_instance();

  void Swap(ClientStatus* other);

  // implements Message ----------------------------------------------

  inline ClientStatus* New() const { return New(NULL); }

  ClientStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStatus& from);
  void MergeFrom(const ClientStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ClientStats stats = 1;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  const ::grpc::testing::ClientStats& stats() const;
  ::grpc::testing::ClientStats* mutable_stats();
  ::grpc::testing::ClientStats* release_stats();
  void set_allocated_stats(::grpc::testing::ClientStats* stats);

  // @@protoc_insertion_point(class_scope:grpc.testing.ClientStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::grpc::testing::ClientStats* stats_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientStatus* default_instance_;
};
// -------------------------------------------------------------------

class ServerConfig : public ::google::protobuf::Message {
 public:
  ServerConfig();
  virtual ~ServerConfig();

  ServerConfig(const ServerConfig& from);

  inline ServerConfig& operator=(const ServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerConfig& default_instance();

  void Swap(ServerConfig* other);

  // implements Message ----------------------------------------------

  inline ServerConfig* New() const { return New(NULL); }

  ServerConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerConfig& from);
  void MergeFrom(const ServerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ServerType server_type = 1;
  void clear_server_type();
  static const int kServerTypeFieldNumber = 1;
  ::grpc::testing::ServerType server_type() const;
  void set_server_type(::grpc::testing::ServerType value);

  // optional int32 threads = 2;
  void clear_threads();
  static const int kThreadsFieldNumber = 2;
  ::google::protobuf::int32 threads() const;
  void set_threads(::google::protobuf::int32 value);

  // optional bool enable_ssl = 3;
  void clear_enable_ssl();
  static const int kEnableSslFieldNumber = 3;
  bool enable_ssl() const;
  void set_enable_ssl(bool value);

  // optional string host = 4;
  void clear_host();
  static const int kHostFieldNumber = 4;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // @@protoc_insertion_point(class_scope:grpc.testing.ServerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int server_type_;
  ::google::protobuf::int32 threads_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  bool enable_ssl_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerConfig* default_instance_;
};
// -------------------------------------------------------------------

class ServerArgs : public ::google::protobuf::Message {
 public:
  ServerArgs();
  virtual ~ServerArgs();

  ServerArgs(const ServerArgs& from);

  inline ServerArgs& operator=(const ServerArgs& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerArgs& default_instance();

  enum ArgtypeCase {
    kSetup = 1,
    kMark = 2,
    ARGTYPE_NOT_SET = 0,
  };

  void Swap(ServerArgs* other);

  // implements Message ----------------------------------------------

  inline ServerArgs* New() const { return New(NULL); }

  ServerArgs* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerArgs& from);
  void MergeFrom(const ServerArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ServerConfig setup = 1;
  bool has_setup() const;
  void clear_setup();
  static const int kSetupFieldNumber = 1;
  const ::grpc::testing::ServerConfig& setup() const;
  ::grpc::testing::ServerConfig* mutable_setup();
  ::grpc::testing::ServerConfig* release_setup();
  void set_allocated_setup(::grpc::testing::ServerConfig* setup);

  // optional .grpc.testing.Mark mark = 2;
  bool has_mark() const;
  void clear_mark();
  static const int kMarkFieldNumber = 2;
  const ::grpc::testing::Mark& mark() const;
  ::grpc::testing::Mark* mutable_mark();
  ::grpc::testing::Mark* release_mark();
  void set_allocated_mark(::grpc::testing::Mark* mark);

  ArgtypeCase argtype_case() const;
  // @@protoc_insertion_point(class_scope:grpc.testing.ServerArgs)
 private:
  inline void set_has_setup();
  inline void set_has_mark();

  inline bool has_argtype() const;
  void clear_argtype();
  inline void clear_has_argtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ArgtypeUnion {
    ArgtypeUnion() {}
    ::grpc::testing::ServerConfig* setup_;
    ::grpc::testing::Mark* mark_;
  } argtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerArgs* default_instance_;
};
// -------------------------------------------------------------------

class ServerStatus : public ::google::protobuf::Message {
 public:
  ServerStatus();
  virtual ~ServerStatus();

  ServerStatus(const ServerStatus& from);

  inline ServerStatus& operator=(const ServerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStatus& default_instance();

  void Swap(ServerStatus* other);

  // implements Message ----------------------------------------------

  inline ServerStatus* New() const { return New(NULL); }

  ServerStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerStatus& from);
  void MergeFrom(const ServerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ServerStats stats = 1;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  const ::grpc::testing::ServerStats& stats() const;
  ::grpc::testing::ServerStats* mutable_stats();
  ::grpc::testing::ServerStats* release_stats();
  void set_allocated_stats(::grpc::testing::ServerStats* stats);

  // optional int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:grpc.testing.ServerStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::grpc::testing::ServerStats* stats_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerStatus* default_instance_;
};
// -------------------------------------------------------------------

class SimpleRequest : public ::google::protobuf::Message {
 public:
  SimpleRequest();
  virtual ~SimpleRequest();

  SimpleRequest(const SimpleRequest& from);

  inline SimpleRequest& operator=(const SimpleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleRequest& default_instance();

  void Swap(SimpleRequest* other);

  // implements Message ----------------------------------------------

  inline SimpleRequest* New() const { return New(NULL); }

  SimpleRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleRequest& from);
  void MergeFrom(const SimpleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.PayloadType response_type = 1;
  void clear_response_type();
  static const int kResponseTypeFieldNumber = 1;
  ::grpc::testing::PayloadType response_type() const;
  void set_response_type(::grpc::testing::PayloadType value);

  // optional int32 response_size = 2;
  void clear_response_size();
  static const int kResponseSizeFieldNumber = 2;
  ::google::protobuf::int32 response_size() const;
  void set_response_size(::google::protobuf::int32 value);

  // optional .grpc.testing.Payload payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::grpc::testing::Payload& payload() const;
  ::grpc::testing::Payload* mutable_payload();
  ::grpc::testing::Payload* release_payload();
  void set_allocated_payload(::grpc::testing::Payload* payload);

  // @@protoc_insertion_point(class_scope:grpc.testing.SimpleRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int response_type_;
  ::google::protobuf::int32 response_size_;
  ::grpc::testing::Payload* payload_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static SimpleRequest* default_instance_;
};
// -------------------------------------------------------------------

class SimpleResponse : public ::google::protobuf::Message {
 public:
  SimpleResponse();
  virtual ~SimpleResponse();

  SimpleResponse(const SimpleResponse& from);

  inline SimpleResponse& operator=(const SimpleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleResponse& default_instance();

  void Swap(SimpleResponse* other);

  // implements Message ----------------------------------------------

  inline SimpleResponse* New() const { return New(NULL); }

  SimpleResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleResponse& from);
  void MergeFrom(const SimpleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.Payload payload = 1;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::grpc::testing::Payload& payload() const;
  ::grpc::testing::Payload* mutable_payload();
  ::grpc::testing::Payload* release_payload();
  void set_allocated_payload(::grpc::testing::Payload* payload);

  // @@protoc_insertion_point(class_scope:grpc.testing.SimpleResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::grpc::testing::Payload* payload_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static SimpleResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// StatsRequest

// optional int32 test_num = 1;
inline void StatsRequest::clear_test_num() {
  test_num_ = 0;
}
inline ::google::protobuf::int32 StatsRequest::test_num() const {
  // @@protoc_insertion_point(field_get:grpc.testing.StatsRequest.test_num)
  return test_num_;
}
inline void StatsRequest::set_test_num(::google::protobuf::int32 value) {
  
  test_num_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.StatsRequest.test_num)
}

// -------------------------------------------------------------------

// ServerStats

// optional double time_elapsed = 1;
inline void ServerStats::clear_time_elapsed() {
  time_elapsed_ = 0;
}
inline double ServerStats::time_elapsed() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStats.time_elapsed)
  return time_elapsed_;
}
inline void ServerStats::set_time_elapsed(double value) {
  
  time_elapsed_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStats.time_elapsed)
}

// optional double time_user = 2;
inline void ServerStats::clear_time_user() {
  time_user_ = 0;
}
inline double ServerStats::time_user() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStats.time_user)
  return time_user_;
}
inline void ServerStats::set_time_user(double value) {
  
  time_user_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStats.time_user)
}

// optional double time_system = 3;
inline void ServerStats::clear_time_system() {
  time_system_ = 0;
}
inline double ServerStats::time_system() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStats.time_system)
  return time_system_;
}
inline void ServerStats::set_time_system(double value) {
  
  time_system_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStats.time_system)
}

// -------------------------------------------------------------------

// Payload

// optional .grpc.testing.PayloadType type = 1;
inline void Payload::clear_type() {
  type_ = 0;
}
inline ::grpc::testing::PayloadType Payload::type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.Payload.type)
  return static_cast< ::grpc::testing::PayloadType >(type_);
}
inline void Payload::set_type(::grpc::testing::PayloadType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.Payload.type)
}

// optional bytes body = 2;
inline void Payload::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Payload::body() const {
  // @@protoc_insertion_point(field_get:grpc.testing.Payload.body)
  return body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Payload::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.testing.Payload.body)
}
inline void Payload::set_body(const char* value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.testing.Payload.body)
}
inline void Payload::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.Payload.body)
}
inline ::std::string* Payload::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:grpc.testing.Payload.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Payload::release_body() {
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Payload::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.Payload.body)
}

// -------------------------------------------------------------------

// HistogramData

// repeated uint32 bucket = 1;
inline int HistogramData::bucket_size() const {
  return bucket_.size();
}
inline void HistogramData::clear_bucket() {
  bucket_.Clear();
}
inline ::google::protobuf::uint32 HistogramData::bucket(int index) const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.bucket)
  return bucket_.Get(index);
}
inline void HistogramData::set_bucket(int index, ::google::protobuf::uint32 value) {
  bucket_.Set(index, value);
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.bucket)
}
inline void HistogramData::add_bucket(::google::protobuf::uint32 value) {
  bucket_.Add(value);
  // @@protoc_insertion_point(field_add:grpc.testing.HistogramData.bucket)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HistogramData::bucket() const {
  // @@protoc_insertion_point(field_list:grpc.testing.HistogramData.bucket)
  return bucket_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HistogramData::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:grpc.testing.HistogramData.bucket)
  return &bucket_;
}

// optional double min_seen = 2;
inline void HistogramData::clear_min_seen() {
  min_seen_ = 0;
}
inline double HistogramData::min_seen() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.min_seen)
  return min_seen_;
}
inline void HistogramData::set_min_seen(double value) {
  
  min_seen_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.min_seen)
}

// optional double max_seen = 3;
inline void HistogramData::clear_max_seen() {
  max_seen_ = 0;
}
inline double HistogramData::max_seen() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.max_seen)
  return max_seen_;
}
inline void HistogramData::set_max_seen(double value) {
  
  max_seen_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.max_seen)
}

// optional double sum = 4;
inline void HistogramData::clear_sum() {
  sum_ = 0;
}
inline double HistogramData::sum() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.sum)
  return sum_;
}
inline void HistogramData::set_sum(double value) {
  
  sum_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.sum)
}

// optional double sum_of_squares = 5;
inline void HistogramData::clear_sum_of_squares() {
  sum_of_squares_ = 0;
}
inline double HistogramData::sum_of_squares() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.sum_of_squares)
  return sum_of_squares_;
}
inline void HistogramData::set_sum_of_squares(double value) {
  
  sum_of_squares_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.sum_of_squares)
}

// optional double count = 6;
inline void HistogramData::clear_count() {
  count_ = 0;
}
inline double HistogramData::count() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.count)
  return count_;
}
inline void HistogramData::set_count(double value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.count)
}

// -------------------------------------------------------------------

// PoissonParams

// optional double offered_load = 1;
inline void PoissonParams::clear_offered_load() {
  offered_load_ = 0;
}
inline double PoissonParams::offered_load() const {
  // @@protoc_insertion_point(field_get:grpc.testing.PoissonParams.offered_load)
  return offered_load_;
}
inline void PoissonParams::set_offered_load(double value) {
  
  offered_load_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.PoissonParams.offered_load)
}

// -------------------------------------------------------------------

// UniformParams

// optional double interarrival_lo = 1;
inline void UniformParams::clear_interarrival_lo() {
  interarrival_lo_ = 0;
}
inline double UniformParams::interarrival_lo() const {
  // @@protoc_insertion_point(field_get:grpc.testing.UniformParams.interarrival_lo)
  return interarrival_lo_;
}
inline void UniformParams::set_interarrival_lo(double value) {
  
  interarrival_lo_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.UniformParams.interarrival_lo)
}

// optional double interarrival_hi = 2;
inline void UniformParams::clear_interarrival_hi() {
  interarrival_hi_ = 0;
}
inline double UniformParams::interarrival_hi() const {
  // @@protoc_insertion_point(field_get:grpc.testing.UniformParams.interarrival_hi)
  return interarrival_hi_;
}
inline void UniformParams::set_interarrival_hi(double value) {
  
  interarrival_hi_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.UniformParams.interarrival_hi)
}

// -------------------------------------------------------------------

// DeterministicParams

// optional double offered_load = 1;
inline void DeterministicParams::clear_offered_load() {
  offered_load_ = 0;
}
inline double DeterministicParams::offered_load() const {
  // @@protoc_insertion_point(field_get:grpc.testing.DeterministicParams.offered_load)
  return offered_load_;
}
inline void DeterministicParams::set_offered_load(double value) {
  
  offered_load_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.DeterministicParams.offered_load)
}

// -------------------------------------------------------------------

// ParetoParams

// optional double interarrival_base = 1;
inline void ParetoParams::clear_interarrival_base() {
  interarrival_base_ = 0;
}
inline double ParetoParams::interarrival_base() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ParetoParams.interarrival_base)
  return interarrival_base_;
}
inline void ParetoParams::set_interarrival_base(double value) {
  
  interarrival_base_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ParetoParams.interarrival_base)
}

// optional double alpha = 2;
inline void ParetoParams::clear_alpha() {
  alpha_ = 0;
}
inline double ParetoParams::alpha() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ParetoParams.alpha)
  return alpha_;
}
inline void ParetoParams::set_alpha(double value) {
  
  alpha_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ParetoParams.alpha)
}

// -------------------------------------------------------------------

// LoadParams

// optional .grpc.testing.PoissonParams poisson = 1;
inline bool LoadParams::has_poisson() const {
  return load_case() == kPoisson;
}
inline void LoadParams::set_has_poisson() {
  _oneof_case_[0] = kPoisson;
}
inline void LoadParams::clear_poisson() {
  if (has_poisson()) {
    delete load_.poisson_;
    clear_has_load();
  }
}
inline const ::grpc::testing::PoissonParams& LoadParams::poisson() const {
  // @@protoc_insertion_point(field_get:grpc.testing.LoadParams.poisson)
  return has_poisson() ? *load_.poisson_
                      : ::grpc::testing::PoissonParams::default_instance();
}
inline ::grpc::testing::PoissonParams* LoadParams::mutable_poisson() {
  if (!has_poisson()) {
    clear_load();
    set_has_poisson();
    load_.poisson_ = new ::grpc::testing::PoissonParams;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.LoadParams.poisson)
  return load_.poisson_;
}
inline ::grpc::testing::PoissonParams* LoadParams::release_poisson() {
  if (has_poisson()) {
    clear_has_load();
    ::grpc::testing::PoissonParams* temp = load_.poisson_;
    load_.poisson_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LoadParams::set_allocated_poisson(::grpc::testing::PoissonParams* poisson) {
  clear_load();
  if (poisson) {
    set_has_poisson();
    load_.poisson_ = poisson;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.LoadParams.poisson)
}

// optional .grpc.testing.UniformParams uniform = 2;
inline bool LoadParams::has_uniform() const {
  return load_case() == kUniform;
}
inline void LoadParams::set_has_uniform() {
  _oneof_case_[0] = kUniform;
}
inline void LoadParams::clear_uniform() {
  if (has_uniform()) {
    delete load_.uniform_;
    clear_has_load();
  }
}
inline const ::grpc::testing::UniformParams& LoadParams::uniform() const {
  // @@protoc_insertion_point(field_get:grpc.testing.LoadParams.uniform)
  return has_uniform() ? *load_.uniform_
                      : ::grpc::testing::UniformParams::default_instance();
}
inline ::grpc::testing::UniformParams* LoadParams::mutable_uniform() {
  if (!has_uniform()) {
    clear_load();
    set_has_uniform();
    load_.uniform_ = new ::grpc::testing::UniformParams;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.LoadParams.uniform)
  return load_.uniform_;
}
inline ::grpc::testing::UniformParams* LoadParams::release_uniform() {
  if (has_uniform()) {
    clear_has_load();
    ::grpc::testing::UniformParams* temp = load_.uniform_;
    load_.uniform_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LoadParams::set_allocated_uniform(::grpc::testing::UniformParams* uniform) {
  clear_load();
  if (uniform) {
    set_has_uniform();
    load_.uniform_ = uniform;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.LoadParams.uniform)
}

// optional .grpc.testing.DeterministicParams determ = 3;
inline bool LoadParams::has_determ() const {
  return load_case() == kDeterm;
}
inline void LoadParams::set_has_determ() {
  _oneof_case_[0] = kDeterm;
}
inline void LoadParams::clear_determ() {
  if (has_determ()) {
    delete load_.determ_;
    clear_has_load();
  }
}
inline const ::grpc::testing::DeterministicParams& LoadParams::determ() const {
  // @@protoc_insertion_point(field_get:grpc.testing.LoadParams.determ)
  return has_determ() ? *load_.determ_
                      : ::grpc::testing::DeterministicParams::default_instance();
}
inline ::grpc::testing::DeterministicParams* LoadParams::mutable_determ() {
  if (!has_determ()) {
    clear_load();
    set_has_determ();
    load_.determ_ = new ::grpc::testing::DeterministicParams;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.LoadParams.determ)
  return load_.determ_;
}
inline ::grpc::testing::DeterministicParams* LoadParams::release_determ() {
  if (has_determ()) {
    clear_has_load();
    ::grpc::testing::DeterministicParams* temp = load_.determ_;
    load_.determ_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LoadParams::set_allocated_determ(::grpc::testing::DeterministicParams* determ) {
  clear_load();
  if (determ) {
    set_has_determ();
    load_.determ_ = determ;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.LoadParams.determ)
}

// optional .grpc.testing.ParetoParams pareto = 4;
inline bool LoadParams::has_pareto() const {
  return load_case() == kPareto;
}
inline void LoadParams::set_has_pareto() {
  _oneof_case_[0] = kPareto;
}
inline void LoadParams::clear_pareto() {
  if (has_pareto()) {
    delete load_.pareto_;
    clear_has_load();
  }
}
inline const ::grpc::testing::ParetoParams& LoadParams::pareto() const {
  // @@protoc_insertion_point(field_get:grpc.testing.LoadParams.pareto)
  return has_pareto() ? *load_.pareto_
                      : ::grpc::testing::ParetoParams::default_instance();
}
inline ::grpc::testing::ParetoParams* LoadParams::mutable_pareto() {
  if (!has_pareto()) {
    clear_load();
    set_has_pareto();
    load_.pareto_ = new ::grpc::testing::ParetoParams;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.LoadParams.pareto)
  return load_.pareto_;
}
inline ::grpc::testing::ParetoParams* LoadParams::release_pareto() {
  if (has_pareto()) {
    clear_has_load();
    ::grpc::testing::ParetoParams* temp = load_.pareto_;
    load_.pareto_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LoadParams::set_allocated_pareto(::grpc::testing::ParetoParams* pareto) {
  clear_load();
  if (pareto) {
    set_has_pareto();
    load_.pareto_ = pareto;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.LoadParams.pareto)
}

inline bool LoadParams::has_load() const {
  return load_case() != LOAD_NOT_SET;
}
inline void LoadParams::clear_has_load() {
  _oneof_case_[0] = LOAD_NOT_SET;
}
inline LoadParams::LoadCase LoadParams::load_case() const {
  return LoadParams::LoadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientConfig

// repeated string server_targets = 1;
inline int ClientConfig::server_targets_size() const {
  return server_targets_.size();
}
inline void ClientConfig::clear_server_targets() {
  server_targets_.Clear();
}
inline const ::std::string& ClientConfig::server_targets(int index) const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.server_targets)
  return server_targets_.Get(index);
}
inline ::std::string* ClientConfig::mutable_server_targets(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientConfig.server_targets)
  return server_targets_.Mutable(index);
}
inline void ClientConfig::set_server_targets(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.server_targets)
  server_targets_.Mutable(index)->assign(value);
}
inline void ClientConfig::set_server_targets(int index, const char* value) {
  server_targets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.testing.ClientConfig.server_targets)
}
inline void ClientConfig::set_server_targets(int index, const char* value, size_t size) {
  server_targets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.ClientConfig.server_targets)
}
inline ::std::string* ClientConfig::add_server_targets() {
  return server_targets_.Add();
}
inline void ClientConfig::add_server_targets(const ::std::string& value) {
  server_targets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.testing.ClientConfig.server_targets)
}
inline void ClientConfig::add_server_targets(const char* value) {
  server_targets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.testing.ClientConfig.server_targets)
}
inline void ClientConfig::add_server_targets(const char* value, size_t size) {
  server_targets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.testing.ClientConfig.server_targets)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientConfig::server_targets() const {
  // @@protoc_insertion_point(field_list:grpc.testing.ClientConfig.server_targets)
  return server_targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientConfig::mutable_server_targets() {
  // @@protoc_insertion_point(field_mutable_list:grpc.testing.ClientConfig.server_targets)
  return &server_targets_;
}

// optional .grpc.testing.ClientType client_type = 2;
inline void ClientConfig::clear_client_type() {
  client_type_ = 0;
}
inline ::grpc::testing::ClientType ClientConfig::client_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.client_type)
  return static_cast< ::grpc::testing::ClientType >(client_type_);
}
inline void ClientConfig::set_client_type(::grpc::testing::ClientType value) {
  
  client_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.client_type)
}

// optional bool enable_ssl = 3;
inline void ClientConfig::clear_enable_ssl() {
  enable_ssl_ = false;
}
inline bool ClientConfig::enable_ssl() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.enable_ssl)
  return enable_ssl_;
}
inline void ClientConfig::set_enable_ssl(bool value) {
  
  enable_ssl_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.enable_ssl)
}

// optional int32 outstanding_rpcs_per_channel = 4;
inline void ClientConfig::clear_outstanding_rpcs_per_channel() {
  outstanding_rpcs_per_channel_ = 0;
}
inline ::google::protobuf::int32 ClientConfig::outstanding_rpcs_per_channel() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.outstanding_rpcs_per_channel)
  return outstanding_rpcs_per_channel_;
}
inline void ClientConfig::set_outstanding_rpcs_per_channel(::google::protobuf::int32 value) {
  
  outstanding_rpcs_per_channel_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.outstanding_rpcs_per_channel)
}

// optional int32 client_channels = 5;
inline void ClientConfig::clear_client_channels() {
  client_channels_ = 0;
}
inline ::google::protobuf::int32 ClientConfig::client_channels() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.client_channels)
  return client_channels_;
}
inline void ClientConfig::set_client_channels(::google::protobuf::int32 value) {
  
  client_channels_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.client_channels)
}

// optional int32 payload_size = 6;
inline void ClientConfig::clear_payload_size() {
  payload_size_ = 0;
}
inline ::google::protobuf::int32 ClientConfig::payload_size() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.payload_size)
  return payload_size_;
}
inline void ClientConfig::set_payload_size(::google::protobuf::int32 value) {
  
  payload_size_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.payload_size)
}

// optional int32 async_client_threads = 7;
inline void ClientConfig::clear_async_client_threads() {
  async_client_threads_ = 0;
}
inline ::google::protobuf::int32 ClientConfig::async_client_threads() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.async_client_threads)
  return async_client_threads_;
}
inline void ClientConfig::set_async_client_threads(::google::protobuf::int32 value) {
  
  async_client_threads_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.async_client_threads)
}

// optional .grpc.testing.RpcType rpc_type = 8;
inline void ClientConfig::clear_rpc_type() {
  rpc_type_ = 0;
}
inline ::grpc::testing::RpcType ClientConfig::rpc_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.rpc_type)
  return static_cast< ::grpc::testing::RpcType >(rpc_type_);
}
inline void ClientConfig::set_rpc_type(::grpc::testing::RpcType value) {
  
  rpc_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.rpc_type)
}

// optional string host = 9;
inline void ClientConfig::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientConfig::host() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.host)
  return host_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConfig::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.host)
}
inline void ClientConfig::set_host(const char* value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.testing.ClientConfig.host)
}
inline void ClientConfig::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.ClientConfig.host)
}
inline ::std::string* ClientConfig::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientConfig.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientConfig::release_host() {
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConfig::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientConfig.host)
}

// optional .grpc.testing.LoadType load_type = 10;
inline void ClientConfig::clear_load_type() {
  load_type_ = 0;
}
inline ::grpc::testing::LoadType ClientConfig::load_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.load_type)
  return static_cast< ::grpc::testing::LoadType >(load_type_);
}
inline void ClientConfig::set_load_type(::grpc::testing::LoadType value) {
  
  load_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.load_type)
}

// optional .grpc.testing.LoadParams load_params = 11;
inline bool ClientConfig::has_load_params() const {
  return !_is_default_instance_ && load_params_ != NULL;
}
inline void ClientConfig::clear_load_params() {
  if (GetArenaNoVirtual() == NULL && load_params_ != NULL) delete load_params_;
  load_params_ = NULL;
}
inline const ::grpc::testing::LoadParams& ClientConfig::load_params() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.load_params)
  return load_params_ != NULL ? *load_params_ : *default_instance_->load_params_;
}
inline ::grpc::testing::LoadParams* ClientConfig::mutable_load_params() {
  
  if (load_params_ == NULL) {
    load_params_ = new ::grpc::testing::LoadParams;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientConfig.load_params)
  return load_params_;
}
inline ::grpc::testing::LoadParams* ClientConfig::release_load_params() {
  
  ::grpc::testing::LoadParams* temp = load_params_;
  load_params_ = NULL;
  return temp;
}
inline void ClientConfig::set_allocated_load_params(::grpc::testing::LoadParams* load_params) {
  delete load_params_;
  load_params_ = load_params;
  if (load_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientConfig.load_params)
}

// -------------------------------------------------------------------

// Mark

// -------------------------------------------------------------------

// ClientArgs

// optional .grpc.testing.ClientConfig setup = 1;
inline bool ClientArgs::has_setup() const {
  return argtype_case() == kSetup;
}
inline void ClientArgs::set_has_setup() {
  _oneof_case_[0] = kSetup;
}
inline void ClientArgs::clear_setup() {
  if (has_setup()) {
    delete argtype_.setup_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::ClientConfig& ClientArgs::setup() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientArgs.setup)
  return has_setup() ? *argtype_.setup_
                      : ::grpc::testing::ClientConfig::default_instance();
}
inline ::grpc::testing::ClientConfig* ClientArgs::mutable_setup() {
  if (!has_setup()) {
    clear_argtype();
    set_has_setup();
    argtype_.setup_ = new ::grpc::testing::ClientConfig;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientArgs.setup)
  return argtype_.setup_;
}
inline ::grpc::testing::ClientConfig* ClientArgs::release_setup() {
  if (has_setup()) {
    clear_has_argtype();
    ::grpc::testing::ClientConfig* temp = argtype_.setup_;
    argtype_.setup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientArgs::set_allocated_setup(::grpc::testing::ClientConfig* setup) {
  clear_argtype();
  if (setup) {
    set_has_setup();
    argtype_.setup_ = setup;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientArgs.setup)
}

// optional .grpc.testing.Mark mark = 2;
inline bool ClientArgs::has_mark() const {
  return argtype_case() == kMark;
}
inline void ClientArgs::set_has_mark() {
  _oneof_case_[0] = kMark;
}
inline void ClientArgs::clear_mark() {
  if (has_mark()) {
    delete argtype_.mark_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::Mark& ClientArgs::mark() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientArgs.mark)
  return has_mark() ? *argtype_.mark_
                      : ::grpc::testing::Mark::default_instance();
}
inline ::grpc::testing::Mark* ClientArgs::mutable_mark() {
  if (!has_mark()) {
    clear_argtype();
    set_has_mark();
    argtype_.mark_ = new ::grpc::testing::Mark;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientArgs.mark)
  return argtype_.mark_;
}
inline ::grpc::testing::Mark* ClientArgs::release_mark() {
  if (has_mark()) {
    clear_has_argtype();
    ::grpc::testing::Mark* temp = argtype_.mark_;
    argtype_.mark_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientArgs::set_allocated_mark(::grpc::testing::Mark* mark) {
  clear_argtype();
  if (mark) {
    set_has_mark();
    argtype_.mark_ = mark;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientArgs.mark)
}

inline bool ClientArgs::has_argtype() const {
  return argtype_case() != ARGTYPE_NOT_SET;
}
inline void ClientArgs::clear_has_argtype() {
  _oneof_case_[0] = ARGTYPE_NOT_SET;
}
inline ClientArgs::ArgtypeCase ClientArgs::argtype_case() const {
  return ClientArgs::ArgtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientStats

// optional .grpc.testing.HistogramData latencies = 1;
inline bool ClientStats::has_latencies() const {
  return !_is_default_instance_ && latencies_ != NULL;
}
inline void ClientStats::clear_latencies() {
  if (GetArenaNoVirtual() == NULL && latencies_ != NULL) delete latencies_;
  latencies_ = NULL;
}
inline const ::grpc::testing::HistogramData& ClientStats::latencies() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.latencies)
  return latencies_ != NULL ? *latencies_ : *default_instance_->latencies_;
}
inline ::grpc::testing::HistogramData* ClientStats::mutable_latencies() {
  
  if (latencies_ == NULL) {
    latencies_ = new ::grpc::testing::HistogramData;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientStats.latencies)
  return latencies_;
}
inline ::grpc::testing::HistogramData* ClientStats::release_latencies() {
  
  ::grpc::testing::HistogramData* temp = latencies_;
  latencies_ = NULL;
  return temp;
}
inline void ClientStats::set_allocated_latencies(::grpc::testing::HistogramData* latencies) {
  delete latencies_;
  latencies_ = latencies;
  if (latencies) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientStats.latencies)
}

// optional double time_elapsed = 2;
inline void ClientStats::clear_time_elapsed() {
  time_elapsed_ = 0;
}
inline double ClientStats::time_elapsed() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.time_elapsed)
  return time_elapsed_;
}
inline void ClientStats::set_time_elapsed(double value) {
  
  time_elapsed_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientStats.time_elapsed)
}

// optional double time_user = 3;
inline void ClientStats::clear_time_user() {
  time_user_ = 0;
}
inline double ClientStats::time_user() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.time_user)
  return time_user_;
}
inline void ClientStats::set_time_user(double value) {
  
  time_user_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientStats.time_user)
}

// optional double time_system = 4;
inline void ClientStats::clear_time_system() {
  time_system_ = 0;
}
inline double ClientStats::time_system() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.time_system)
  return time_system_;
}
inline void ClientStats::set_time_system(double value) {
  
  time_system_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientStats.time_system)
}

// -------------------------------------------------------------------

// ClientStatus

// optional .grpc.testing.ClientStats stats = 1;
inline bool ClientStatus::has_stats() const {
  return !_is_default_instance_ && stats_ != NULL;
}
inline void ClientStatus::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) delete stats_;
  stats_ = NULL;
}
inline const ::grpc::testing::ClientStats& ClientStatus::stats() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStatus.stats)
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::grpc::testing::ClientStats* ClientStatus::mutable_stats() {
  
  if (stats_ == NULL) {
    stats_ = new ::grpc::testing::ClientStats;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientStatus.stats)
  return stats_;
}
inline ::grpc::testing::ClientStats* ClientStatus::release_stats() {
  
  ::grpc::testing::ClientStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void ClientStatus::set_allocated_stats(::grpc::testing::ClientStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientStatus.stats)
}

// -------------------------------------------------------------------

// ServerConfig

// optional .grpc.testing.ServerType server_type = 1;
inline void ServerConfig::clear_server_type() {
  server_type_ = 0;
}
inline ::grpc::testing::ServerType ServerConfig::server_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.server_type)
  return static_cast< ::grpc::testing::ServerType >(server_type_);
}
inline void ServerConfig::set_server_type(::grpc::testing::ServerType value) {
  
  server_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.server_type)
}

// optional int32 threads = 2;
inline void ServerConfig::clear_threads() {
  threads_ = 0;
}
inline ::google::protobuf::int32 ServerConfig::threads() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.threads)
  return threads_;
}
inline void ServerConfig::set_threads(::google::protobuf::int32 value) {
  
  threads_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.threads)
}

// optional bool enable_ssl = 3;
inline void ServerConfig::clear_enable_ssl() {
  enable_ssl_ = false;
}
inline bool ServerConfig::enable_ssl() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.enable_ssl)
  return enable_ssl_;
}
inline void ServerConfig::set_enable_ssl(bool value) {
  
  enable_ssl_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.enable_ssl)
}

// optional string host = 4;
inline void ServerConfig::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerConfig::host() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.host)
  return host_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerConfig::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.host)
}
inline void ServerConfig::set_host(const char* value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.testing.ServerConfig.host)
}
inline void ServerConfig::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.ServerConfig.host)
}
inline ::std::string* ServerConfig::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerConfig.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerConfig::release_host() {
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerConfig::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerConfig.host)
}

// -------------------------------------------------------------------

// ServerArgs

// optional .grpc.testing.ServerConfig setup = 1;
inline bool ServerArgs::has_setup() const {
  return argtype_case() == kSetup;
}
inline void ServerArgs::set_has_setup() {
  _oneof_case_[0] = kSetup;
}
inline void ServerArgs::clear_setup() {
  if (has_setup()) {
    delete argtype_.setup_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::ServerConfig& ServerArgs::setup() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerArgs.setup)
  return has_setup() ? *argtype_.setup_
                      : ::grpc::testing::ServerConfig::default_instance();
}
inline ::grpc::testing::ServerConfig* ServerArgs::mutable_setup() {
  if (!has_setup()) {
    clear_argtype();
    set_has_setup();
    argtype_.setup_ = new ::grpc::testing::ServerConfig;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerArgs.setup)
  return argtype_.setup_;
}
inline ::grpc::testing::ServerConfig* ServerArgs::release_setup() {
  if (has_setup()) {
    clear_has_argtype();
    ::grpc::testing::ServerConfig* temp = argtype_.setup_;
    argtype_.setup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerArgs::set_allocated_setup(::grpc::testing::ServerConfig* setup) {
  clear_argtype();
  if (setup) {
    set_has_setup();
    argtype_.setup_ = setup;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerArgs.setup)
}

// optional .grpc.testing.Mark mark = 2;
inline bool ServerArgs::has_mark() const {
  return argtype_case() == kMark;
}
inline void ServerArgs::set_has_mark() {
  _oneof_case_[0] = kMark;
}
inline void ServerArgs::clear_mark() {
  if (has_mark()) {
    delete argtype_.mark_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::Mark& ServerArgs::mark() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerArgs.mark)
  return has_mark() ? *argtype_.mark_
                      : ::grpc::testing::Mark::default_instance();
}
inline ::grpc::testing::Mark* ServerArgs::mutable_mark() {
  if (!has_mark()) {
    clear_argtype();
    set_has_mark();
    argtype_.mark_ = new ::grpc::testing::Mark;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerArgs.mark)
  return argtype_.mark_;
}
inline ::grpc::testing::Mark* ServerArgs::release_mark() {
  if (has_mark()) {
    clear_has_argtype();
    ::grpc::testing::Mark* temp = argtype_.mark_;
    argtype_.mark_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerArgs::set_allocated_mark(::grpc::testing::Mark* mark) {
  clear_argtype();
  if (mark) {
    set_has_mark();
    argtype_.mark_ = mark;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerArgs.mark)
}

inline bool ServerArgs::has_argtype() const {
  return argtype_case() != ARGTYPE_NOT_SET;
}
inline void ServerArgs::clear_has_argtype() {
  _oneof_case_[0] = ARGTYPE_NOT_SET;
}
inline ServerArgs::ArgtypeCase ServerArgs::argtype_case() const {
  return ServerArgs::ArgtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerStatus

// optional .grpc.testing.ServerStats stats = 1;
inline bool ServerStatus::has_stats() const {
  return !_is_default_instance_ && stats_ != NULL;
}
inline void ServerStatus::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) delete stats_;
  stats_ = NULL;
}
inline const ::grpc::testing::ServerStats& ServerStatus::stats() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStatus.stats)
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::grpc::testing::ServerStats* ServerStatus::mutable_stats() {
  
  if (stats_ == NULL) {
    stats_ = new ::grpc::testing::ServerStats;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerStatus.stats)
  return stats_;
}
inline ::grpc::testing::ServerStats* ServerStatus::release_stats() {
  
  ::grpc::testing::ServerStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void ServerStatus::set_allocated_stats(::grpc::testing::ServerStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerStatus.stats)
}

// optional int32 port = 2;
inline void ServerStatus::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 ServerStatus::port() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStatus.port)
  return port_;
}
inline void ServerStatus::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStatus.port)
}

// -------------------------------------------------------------------

// SimpleRequest

// optional .grpc.testing.PayloadType response_type = 1;
inline void SimpleRequest::clear_response_type() {
  response_type_ = 0;
}
inline ::grpc::testing::PayloadType SimpleRequest::response_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleRequest.response_type)
  return static_cast< ::grpc::testing::PayloadType >(response_type_);
}
inline void SimpleRequest::set_response_type(::grpc::testing::PayloadType value) {
  
  response_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.SimpleRequest.response_type)
}

// optional int32 response_size = 2;
inline void SimpleRequest::clear_response_size() {
  response_size_ = 0;
}
inline ::google::protobuf::int32 SimpleRequest::response_size() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleRequest.response_size)
  return response_size_;
}
inline void SimpleRequest::set_response_size(::google::protobuf::int32 value) {
  
  response_size_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.SimpleRequest.response_size)
}

// optional .grpc.testing.Payload payload = 3;
inline bool SimpleRequest::has_payload() const {
  return !_is_default_instance_ && payload_ != NULL;
}
inline void SimpleRequest::clear_payload() {
  if (GetArenaNoVirtual() == NULL && payload_ != NULL) delete payload_;
  payload_ = NULL;
}
inline const ::grpc::testing::Payload& SimpleRequest::payload() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleRequest.payload)
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
}
inline ::grpc::testing::Payload* SimpleRequest::mutable_payload() {
  
  if (payload_ == NULL) {
    payload_ = new ::grpc::testing::Payload;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.SimpleRequest.payload)
  return payload_;
}
inline ::grpc::testing::Payload* SimpleRequest::release_payload() {
  
  ::grpc::testing::Payload* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void SimpleRequest::set_allocated_payload(::grpc::testing::Payload* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.SimpleRequest.payload)
}

// -------------------------------------------------------------------

// SimpleResponse

// optional .grpc.testing.Payload payload = 1;
inline bool SimpleResponse::has_payload() const {
  return !_is_default_instance_ && payload_ != NULL;
}
inline void SimpleResponse::clear_payload() {
  if (GetArenaNoVirtual() == NULL && payload_ != NULL) delete payload_;
  payload_ = NULL;
}
inline const ::grpc::testing::Payload& SimpleResponse::payload() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleResponse.payload)
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
}
inline ::grpc::testing::Payload* SimpleResponse::mutable_payload() {
  
  if (payload_ == NULL) {
    payload_ = new ::grpc::testing::Payload;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.SimpleResponse.payload)
  return payload_;
}
inline ::grpc::testing::Payload* SimpleResponse::release_payload() {
  
  ::grpc::testing::Payload* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void SimpleResponse::set_allocated_payload(::grpc::testing::Payload* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.SimpleResponse.payload)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace testing
}  // namespace grpc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::grpc::testing::PayloadType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::PayloadType>() {
  return ::grpc::testing::PayloadType_descriptor();
}
template <> struct is_proto_enum< ::grpc::testing::ClientType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::ClientType>() {
  return ::grpc::testing::ClientType_descriptor();
}
template <> struct is_proto_enum< ::grpc::testing::ServerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::ServerType>() {
  return ::grpc::testing::ServerType_descriptor();
}
template <> struct is_proto_enum< ::grpc::testing::RpcType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::RpcType>() {
  return ::grpc::testing::RpcType_descriptor();
}
template <> struct is_proto_enum< ::grpc::testing::LoadType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::LoadType>() {
  return ::grpc::testing::LoadType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_qpstest_2eproto__INCLUDED
