// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qpstest.proto

#ifndef PROTOBUF_qpstest_2eproto__INCLUDED
#define PROTOBUF_qpstest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace grpc {
namespace testing {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_qpstest_2eproto();
void protobuf_AssignDesc_qpstest_2eproto();
void protobuf_ShutdownFile_qpstest_2eproto();

class StatsRequest;
class ServerStats;
class Payload;
class HistogramData;
class ClientConfig;
class Mark;
class ClientArgs;
class ClientStats;
class ClientStatus;
class ServerConfig;
class ServerArgs;
class ServerStatus;
class SimpleRequest;
class SimpleResponse;

enum PayloadType {
  COMPRESSABLE = 1,
  UNCOMPRESSABLE = 2,
  RANDOM = 3
};
bool PayloadType_IsValid(int value);
const PayloadType PayloadType_MIN = COMPRESSABLE;
const PayloadType PayloadType_MAX = RANDOM;
const int PayloadType_ARRAYSIZE = PayloadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PayloadType_descriptor();
inline const ::std::string& PayloadType_Name(PayloadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PayloadType_descriptor(), value);
}
inline bool PayloadType_Parse(
    const ::std::string& name, PayloadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PayloadType>(
    PayloadType_descriptor(), name, value);
}
enum ClientType {
  SYNCHRONOUS_CLIENT = 1,
  ASYNC_CLIENT = 2
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = SYNCHRONOUS_CLIENT;
const ClientType ClientType_MAX = ASYNC_CLIENT;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientType_descriptor();
inline const ::std::string& ClientType_Name(ClientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientType_descriptor(), value);
}
inline bool ClientType_Parse(
    const ::std::string& name, ClientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum ServerType {
  SYNCHRONOUS_SERVER = 1,
  ASYNC_SERVER = 2
};
bool ServerType_IsValid(int value);
const ServerType ServerType_MIN = SYNCHRONOUS_SERVER;
const ServerType ServerType_MAX = ASYNC_SERVER;
const int ServerType_ARRAYSIZE = ServerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerType_descriptor();
inline const ::std::string& ServerType_Name(ServerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerType_descriptor(), value);
}
inline bool ServerType_Parse(
    const ::std::string& name, ServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerType>(
    ServerType_descriptor(), name, value);
}
enum RpcType {
  UNARY = 1,
  STREAMING = 2
};
bool RpcType_IsValid(int value);
const RpcType RpcType_MIN = UNARY;
const RpcType RpcType_MAX = STREAMING;
const int RpcType_ARRAYSIZE = RpcType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcType_descriptor();
inline const ::std::string& RpcType_Name(RpcType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcType_descriptor(), value);
}
inline bool RpcType_Parse(
    const ::std::string& name, RpcType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcType>(
    RpcType_descriptor(), name, value);
}
// ===================================================================

class StatsRequest : public ::google::protobuf::Message {
 public:
  StatsRequest();
  virtual ~StatsRequest();

  StatsRequest(const StatsRequest& from);

  inline StatsRequest& operator=(const StatsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatsRequest& default_instance();

  void Swap(StatsRequest* other);

  // implements Message ----------------------------------------------

  inline StatsRequest* New() const { return New(NULL); }

  StatsRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatsRequest& from);
  void MergeFrom(const StatsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 test_num = 1;
  bool has_test_num() const;
  void clear_test_num();
  static const int kTestNumFieldNumber = 1;
  ::google::protobuf::int32 test_num() const;
  void set_test_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:grpc.testing.StatsRequest)
 private:
  inline void set_has_test_num();
  inline void clear_has_test_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 test_num_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static StatsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerStats : public ::google::protobuf::Message {
 public:
  ServerStats();
  virtual ~ServerStats();

  ServerStats(const ServerStats& from);

  inline ServerStats& operator=(const ServerStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStats& default_instance();

  void Swap(ServerStats* other);

  // implements Message ----------------------------------------------

  inline ServerStats* New() const { return New(NULL); }

  ServerStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerStats& from);
  void MergeFrom(const ServerStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time_elapsed = 1;
  bool has_time_elapsed() const;
  void clear_time_elapsed();
  static const int kTimeElapsedFieldNumber = 1;
  double time_elapsed() const;
  void set_time_elapsed(double value);

  // required double time_user = 2;
  bool has_time_user() const;
  void clear_time_user();
  static const int kTimeUserFieldNumber = 2;
  double time_user() const;
  void set_time_user(double value);

  // required double time_system = 3;
  bool has_time_system() const;
  void clear_time_system();
  static const int kTimeSystemFieldNumber = 3;
  double time_system() const;
  void set_time_system(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.ServerStats)
 private:
  inline void set_has_time_elapsed();
  inline void clear_has_time_elapsed();
  inline void set_has_time_user();
  inline void clear_has_time_user();
  inline void set_has_time_system();
  inline void clear_has_time_system();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double time_elapsed_;
  double time_user_;
  double time_system_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerStats* default_instance_;
};
// -------------------------------------------------------------------

class Payload : public ::google::protobuf::Message {
 public:
  Payload();
  virtual ~Payload();

  Payload(const Payload& from);

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Payload& default_instance();

  void Swap(Payload* other);

  // implements Message ----------------------------------------------

  inline Payload* New() const { return New(NULL); }

  Payload* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Payload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.PayloadType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::grpc::testing::PayloadType type() const;
  void set_type(::grpc::testing::PayloadType value);

  // optional bytes body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:grpc.testing.Payload)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  int type_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static Payload* default_instance_;
};
// -------------------------------------------------------------------

class HistogramData : public ::google::protobuf::Message {
 public:
  HistogramData();
  virtual ~HistogramData();

  HistogramData(const HistogramData& from);

  inline HistogramData& operator=(const HistogramData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistogramData& default_instance();

  void Swap(HistogramData* other);

  // implements Message ----------------------------------------------

  inline HistogramData* New() const { return New(NULL); }

  HistogramData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistogramData& from);
  void MergeFrom(const HistogramData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HistogramData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 bucket = 1;
  int bucket_size() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  ::google::protobuf::uint32 bucket(int index) const;
  void set_bucket(int index, ::google::protobuf::uint32 value);
  void add_bucket(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      bucket() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_bucket();

  // required double min_seen = 2;
  bool has_min_seen() const;
  void clear_min_seen();
  static const int kMinSeenFieldNumber = 2;
  double min_seen() const;
  void set_min_seen(double value);

  // required double max_seen = 3;
  bool has_max_seen() const;
  void clear_max_seen();
  static const int kMaxSeenFieldNumber = 3;
  double max_seen() const;
  void set_max_seen(double value);

  // required double sum = 4;
  bool has_sum() const;
  void clear_sum();
  static const int kSumFieldNumber = 4;
  double sum() const;
  void set_sum(double value);

  // required double sum_of_squares = 5;
  bool has_sum_of_squares() const;
  void clear_sum_of_squares();
  static const int kSumOfSquaresFieldNumber = 5;
  double sum_of_squares() const;
  void set_sum_of_squares(double value);

  // required double count = 6;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 6;
  double count() const;
  void set_count(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.HistogramData)
 private:
  inline void set_has_min_seen();
  inline void clear_has_min_seen();
  inline void set_has_max_seen();
  inline void clear_has_max_seen();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_sum_of_squares();
  inline void clear_has_sum_of_squares();
  inline void set_has_count();
  inline void clear_has_count();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > bucket_;
  double min_seen_;
  double max_seen_;
  double sum_;
  double sum_of_squares_;
  double count_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static HistogramData* default_instance_;
};
// -------------------------------------------------------------------

class ClientConfig : public ::google::protobuf::Message {
 public:
  ClientConfig();
  virtual ~ClientConfig();

  ClientConfig(const ClientConfig& from);

  inline ClientConfig& operator=(const ClientConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientConfig& default_instance();

  void Swap(ClientConfig* other);

  // implements Message ----------------------------------------------

  inline ClientConfig* New() const { return New(NULL); }

  ClientConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientConfig& from);
  void MergeFrom(const ClientConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string server_targets = 1;
  int server_targets_size() const;
  void clear_server_targets();
  static const int kServerTargetsFieldNumber = 1;
  const ::std::string& server_targets(int index) const;
  ::std::string* mutable_server_targets(int index);
  void set_server_targets(int index, const ::std::string& value);
  void set_server_targets(int index, const char* value);
  void set_server_targets(int index, const char* value, size_t size);
  ::std::string* add_server_targets();
  void add_server_targets(const ::std::string& value);
  void add_server_targets(const char* value);
  void add_server_targets(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& server_targets() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_server_targets();

  // required .grpc.testing.ClientType client_type = 2;
  bool has_client_type() const;
  void clear_client_type();
  static const int kClientTypeFieldNumber = 2;
  ::grpc::testing::ClientType client_type() const;
  void set_client_type(::grpc::testing::ClientType value);

  // optional bool enable_ssl = 3 [default = false];
  bool has_enable_ssl() const;
  void clear_enable_ssl();
  static const int kEnableSslFieldNumber = 3;
  bool enable_ssl() const;
  void set_enable_ssl(bool value);

  // required int32 outstanding_rpcs_per_channel = 4;
  bool has_outstanding_rpcs_per_channel() const;
  void clear_outstanding_rpcs_per_channel();
  static const int kOutstandingRpcsPerChannelFieldNumber = 4;
  ::google::protobuf::int32 outstanding_rpcs_per_channel() const;
  void set_outstanding_rpcs_per_channel(::google::protobuf::int32 value);

  // required int32 client_channels = 5;
  bool has_client_channels() const;
  void clear_client_channels();
  static const int kClientChannelsFieldNumber = 5;
  ::google::protobuf::int32 client_channels() const;
  void set_client_channels(::google::protobuf::int32 value);

  // required int32 payload_size = 6;
  bool has_payload_size() const;
  void clear_payload_size();
  static const int kPayloadSizeFieldNumber = 6;
  ::google::protobuf::int32 payload_size() const;
  void set_payload_size(::google::protobuf::int32 value);

  // optional int32 async_client_threads = 7;
  bool has_async_client_threads() const;
  void clear_async_client_threads();
  static const int kAsyncClientThreadsFieldNumber = 7;
  ::google::protobuf::int32 async_client_threads() const;
  void set_async_client_threads(::google::protobuf::int32 value);

  // optional .grpc.testing.RpcType rpc_type = 8 [default = UNARY];
  bool has_rpc_type() const;
  void clear_rpc_type();
  static const int kRpcTypeFieldNumber = 8;
  ::grpc::testing::RpcType rpc_type() const;
  void set_rpc_type(::grpc::testing::RpcType value);

  // optional string host = 9;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 9;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // @@protoc_insertion_point(class_scope:grpc.testing.ClientConfig)
 private:
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_enable_ssl();
  inline void clear_has_enable_ssl();
  inline void set_has_outstanding_rpcs_per_channel();
  inline void clear_has_outstanding_rpcs_per_channel();
  inline void set_has_client_channels();
  inline void clear_has_client_channels();
  inline void set_has_payload_size();
  inline void clear_has_payload_size();
  inline void set_has_async_client_threads();
  inline void clear_has_async_client_threads();
  inline void set_has_rpc_type();
  inline void clear_has_rpc_type();
  inline void set_has_host();
  inline void clear_has_host();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> server_targets_;
  int client_type_;
  bool enable_ssl_;
  ::google::protobuf::int32 outstanding_rpcs_per_channel_;
  ::google::protobuf::int32 client_channels_;
  ::google::protobuf::int32 payload_size_;
  ::google::protobuf::int32 async_client_threads_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  int rpc_type_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientConfig* default_instance_;
};
// -------------------------------------------------------------------

class Mark : public ::google::protobuf::Message {
 public:
  Mark();
  virtual ~Mark();

  Mark(const Mark& from);

  inline Mark& operator=(const Mark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mark& default_instance();

  void Swap(Mark* other);

  // implements Message ----------------------------------------------

  inline Mark* New() const { return New(NULL); }

  Mark* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mark& from);
  void MergeFrom(const Mark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.testing.Mark)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static Mark* default_instance_;
};
// -------------------------------------------------------------------

class ClientArgs : public ::google::protobuf::Message {
 public:
  ClientArgs();
  virtual ~ClientArgs();

  ClientArgs(const ClientArgs& from);

  inline ClientArgs& operator=(const ClientArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientArgs& default_instance();

  enum ArgtypeCase {
    kSetup = 1,
    kMark = 2,
    ARGTYPE_NOT_SET = 0,
  };

  void Swap(ClientArgs* other);

  // implements Message ----------------------------------------------

  inline ClientArgs* New() const { return New(NULL); }

  ClientArgs* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientArgs& from);
  void MergeFrom(const ClientArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ClientConfig setup = 1;
  bool has_setup() const;
  void clear_setup();
  static const int kSetupFieldNumber = 1;
  const ::grpc::testing::ClientConfig& setup() const;
  ::grpc::testing::ClientConfig* mutable_setup();
  ::grpc::testing::ClientConfig* release_setup();
  void set_allocated_setup(::grpc::testing::ClientConfig* setup);

  // optional .grpc.testing.Mark mark = 2;
  bool has_mark() const;
  void clear_mark();
  static const int kMarkFieldNumber = 2;
  const ::grpc::testing::Mark& mark() const;
  ::grpc::testing::Mark* mutable_mark();
  ::grpc::testing::Mark* release_mark();
  void set_allocated_mark(::grpc::testing::Mark* mark);

  ArgtypeCase argtype_case() const;
  // @@protoc_insertion_point(class_scope:grpc.testing.ClientArgs)
 private:
  inline void set_has_setup();
  inline void set_has_mark();

  inline bool has_argtype() const;
  void clear_argtype();
  inline void clear_has_argtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ArgtypeUnion {
    ArgtypeUnion() {}
    ::grpc::testing::ClientConfig* setup_;
    ::grpc::testing::Mark* mark_;
  } argtype_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientArgs* default_instance_;
};
// -------------------------------------------------------------------

class ClientStats : public ::google::protobuf::Message {
 public:
  ClientStats();
  virtual ~ClientStats();

  ClientStats(const ClientStats& from);

  inline ClientStats& operator=(const ClientStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStats& default_instance();

  void Swap(ClientStats* other);

  // implements Message ----------------------------------------------

  inline ClientStats* New() const { return New(NULL); }

  ClientStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStats& from);
  void MergeFrom(const ClientStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .grpc.testing.HistogramData latencies = 1;
  bool has_latencies() const;
  void clear_latencies();
  static const int kLatenciesFieldNumber = 1;
  const ::grpc::testing::HistogramData& latencies() const;
  ::grpc::testing::HistogramData* mutable_latencies();
  ::grpc::testing::HistogramData* release_latencies();
  void set_allocated_latencies(::grpc::testing::HistogramData* latencies);

  // required double time_elapsed = 3;
  bool has_time_elapsed() const;
  void clear_time_elapsed();
  static const int kTimeElapsedFieldNumber = 3;
  double time_elapsed() const;
  void set_time_elapsed(double value);

  // required double time_user = 4;
  bool has_time_user() const;
  void clear_time_user();
  static const int kTimeUserFieldNumber = 4;
  double time_user() const;
  void set_time_user(double value);

  // required double time_system = 5;
  bool has_time_system() const;
  void clear_time_system();
  static const int kTimeSystemFieldNumber = 5;
  double time_system() const;
  void set_time_system(double value);

  // @@protoc_insertion_point(class_scope:grpc.testing.ClientStats)
 private:
  inline void set_has_latencies();
  inline void clear_has_latencies();
  inline void set_has_time_elapsed();
  inline void clear_has_time_elapsed();
  inline void set_has_time_user();
  inline void clear_has_time_user();
  inline void set_has_time_system();
  inline void clear_has_time_system();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::grpc::testing::HistogramData* latencies_;
  double time_elapsed_;
  double time_user_;
  double time_system_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientStats* default_instance_;
};
// -------------------------------------------------------------------

class ClientStatus : public ::google::protobuf::Message {
 public:
  ClientStatus();
  virtual ~ClientStatus();

  ClientStatus(const ClientStatus& from);

  inline ClientStatus& operator=(const ClientStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientStatus& default_instance();

  void Swap(ClientStatus* other);

  // implements Message ----------------------------------------------

  inline ClientStatus* New() const { return New(NULL); }

  ClientStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientStatus& from);
  void MergeFrom(const ClientStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ClientStats stats = 1;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  const ::grpc::testing::ClientStats& stats() const;
  ::grpc::testing::ClientStats* mutable_stats();
  ::grpc::testing::ClientStats* release_stats();
  void set_allocated_stats(::grpc::testing::ClientStats* stats);

  // @@protoc_insertion_point(class_scope:grpc.testing.ClientStatus)
 private:
  inline void set_has_stats();
  inline void clear_has_stats();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::grpc::testing::ClientStats* stats_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ClientStatus* default_instance_;
};
// -------------------------------------------------------------------

class ServerConfig : public ::google::protobuf::Message {
 public:
  ServerConfig();
  virtual ~ServerConfig();

  ServerConfig(const ServerConfig& from);

  inline ServerConfig& operator=(const ServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerConfig& default_instance();

  void Swap(ServerConfig* other);

  // implements Message ----------------------------------------------

  inline ServerConfig* New() const { return New(NULL); }

  ServerConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerConfig& from);
  void MergeFrom(const ServerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .grpc.testing.ServerType server_type = 1;
  bool has_server_type() const;
  void clear_server_type();
  static const int kServerTypeFieldNumber = 1;
  ::grpc::testing::ServerType server_type() const;
  void set_server_type(::grpc::testing::ServerType value);

  // optional int32 threads = 2 [default = 1];
  bool has_threads() const;
  void clear_threads();
  static const int kThreadsFieldNumber = 2;
  ::google::protobuf::int32 threads() const;
  void set_threads(::google::protobuf::int32 value);

  // optional bool enable_ssl = 3 [default = false];
  bool has_enable_ssl() const;
  void clear_enable_ssl();
  static const int kEnableSslFieldNumber = 3;
  bool enable_ssl() const;
  void set_enable_ssl(bool value);

  // optional string host = 4;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 4;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // @@protoc_insertion_point(class_scope:grpc.testing.ServerConfig)
 private:
  inline void set_has_server_type();
  inline void clear_has_server_type();
  inline void set_has_threads();
  inline void clear_has_threads();
  inline void set_has_enable_ssl();
  inline void clear_has_enable_ssl();
  inline void set_has_host();
  inline void clear_has_host();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int server_type_;
  ::google::protobuf::int32 threads_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  bool enable_ssl_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerConfig* default_instance_;
};
// -------------------------------------------------------------------

class ServerArgs : public ::google::protobuf::Message {
 public:
  ServerArgs();
  virtual ~ServerArgs();

  ServerArgs(const ServerArgs& from);

  inline ServerArgs& operator=(const ServerArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerArgs& default_instance();

  enum ArgtypeCase {
    kSetup = 1,
    kMark = 2,
    ARGTYPE_NOT_SET = 0,
  };

  void Swap(ServerArgs* other);

  // implements Message ----------------------------------------------

  inline ServerArgs* New() const { return New(NULL); }

  ServerArgs* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerArgs& from);
  void MergeFrom(const ServerArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ServerConfig setup = 1;
  bool has_setup() const;
  void clear_setup();
  static const int kSetupFieldNumber = 1;
  const ::grpc::testing::ServerConfig& setup() const;
  ::grpc::testing::ServerConfig* mutable_setup();
  ::grpc::testing::ServerConfig* release_setup();
  void set_allocated_setup(::grpc::testing::ServerConfig* setup);

  // optional .grpc.testing.Mark mark = 2;
  bool has_mark() const;
  void clear_mark();
  static const int kMarkFieldNumber = 2;
  const ::grpc::testing::Mark& mark() const;
  ::grpc::testing::Mark* mutable_mark();
  ::grpc::testing::Mark* release_mark();
  void set_allocated_mark(::grpc::testing::Mark* mark);

  ArgtypeCase argtype_case() const;
  // @@protoc_insertion_point(class_scope:grpc.testing.ServerArgs)
 private:
  inline void set_has_setup();
  inline void set_has_mark();

  inline bool has_argtype() const;
  void clear_argtype();
  inline void clear_has_argtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ArgtypeUnion {
    ArgtypeUnion() {}
    ::grpc::testing::ServerConfig* setup_;
    ::grpc::testing::Mark* mark_;
  } argtype_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerArgs* default_instance_;
};
// -------------------------------------------------------------------

class ServerStatus : public ::google::protobuf::Message {
 public:
  ServerStatus();
  virtual ~ServerStatus();

  ServerStatus(const ServerStatus& from);

  inline ServerStatus& operator=(const ServerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStatus& default_instance();

  void Swap(ServerStatus* other);

  // implements Message ----------------------------------------------

  inline ServerStatus* New() const { return New(NULL); }

  ServerStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerStatus& from);
  void MergeFrom(const ServerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.ServerStats stats = 1;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  const ::grpc::testing::ServerStats& stats() const;
  ::grpc::testing::ServerStats* mutable_stats();
  ::grpc::testing::ServerStats* release_stats();
  void set_allocated_stats(::grpc::testing::ServerStats* stats);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:grpc.testing.ServerStatus)
 private:
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::grpc::testing::ServerStats* stats_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static ServerStatus* default_instance_;
};
// -------------------------------------------------------------------

class SimpleRequest : public ::google::protobuf::Message {
 public:
  SimpleRequest();
  virtual ~SimpleRequest();

  SimpleRequest(const SimpleRequest& from);

  inline SimpleRequest& operator=(const SimpleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleRequest& default_instance();

  void Swap(SimpleRequest* other);

  // implements Message ----------------------------------------------

  inline SimpleRequest* New() const { return New(NULL); }

  SimpleRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleRequest& from);
  void MergeFrom(const SimpleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.PayloadType response_type = 1 [default = COMPRESSABLE];
  bool has_response_type() const;
  void clear_response_type();
  static const int kResponseTypeFieldNumber = 1;
  ::grpc::testing::PayloadType response_type() const;
  void set_response_type(::grpc::testing::PayloadType value);

  // optional int32 response_size = 2 [default = 0];
  bool has_response_size() const;
  void clear_response_size();
  static const int kResponseSizeFieldNumber = 2;
  ::google::protobuf::int32 response_size() const;
  void set_response_size(::google::protobuf::int32 value);

  // optional .grpc.testing.Payload payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::grpc::testing::Payload& payload() const;
  ::grpc::testing::Payload* mutable_payload();
  ::grpc::testing::Payload* release_payload();
  void set_allocated_payload(::grpc::testing::Payload* payload);

  // @@protoc_insertion_point(class_scope:grpc.testing.SimpleRequest)
 private:
  inline void set_has_response_type();
  inline void clear_has_response_type();
  inline void set_has_response_size();
  inline void clear_has_response_size();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int response_type_;
  ::google::protobuf::int32 response_size_;
  ::grpc::testing::Payload* payload_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static SimpleRequest* default_instance_;
};
// -------------------------------------------------------------------

class SimpleResponse : public ::google::protobuf::Message {
 public:
  SimpleResponse();
  virtual ~SimpleResponse();

  SimpleResponse(const SimpleResponse& from);

  inline SimpleResponse& operator=(const SimpleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleResponse& default_instance();

  void Swap(SimpleResponse* other);

  // implements Message ----------------------------------------------

  inline SimpleResponse* New() const { return New(NULL); }

  SimpleResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleResponse& from);
  void MergeFrom(const SimpleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .grpc.testing.Payload payload = 1;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::grpc::testing::Payload& payload() const;
  ::grpc::testing::Payload* mutable_payload();
  ::grpc::testing::Payload* release_payload();
  void set_allocated_payload(::grpc::testing::Payload* payload);

  // @@protoc_insertion_point(class_scope:grpc.testing.SimpleResponse)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::grpc::testing::Payload* payload_;
  friend void  protobuf_AddDesc_qpstest_2eproto();
  friend void protobuf_AssignDesc_qpstest_2eproto();
  friend void protobuf_ShutdownFile_qpstest_2eproto();

  void InitAsDefaultInstance();
  static SimpleResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// StatsRequest

// optional int32 test_num = 1;
inline bool StatsRequest::has_test_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatsRequest::set_has_test_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatsRequest::clear_has_test_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatsRequest::clear_test_num() {
  test_num_ = 0;
  clear_has_test_num();
}
inline ::google::protobuf::int32 StatsRequest::test_num() const {
  // @@protoc_insertion_point(field_get:grpc.testing.StatsRequest.test_num)
  return test_num_;
}
inline void StatsRequest::set_test_num(::google::protobuf::int32 value) {
  set_has_test_num();
  test_num_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.StatsRequest.test_num)
}

// -------------------------------------------------------------------

// ServerStats

// required double time_elapsed = 1;
inline bool ServerStats::has_time_elapsed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStats::set_has_time_elapsed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStats::clear_has_time_elapsed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStats::clear_time_elapsed() {
  time_elapsed_ = 0;
  clear_has_time_elapsed();
}
inline double ServerStats::time_elapsed() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStats.time_elapsed)
  return time_elapsed_;
}
inline void ServerStats::set_time_elapsed(double value) {
  set_has_time_elapsed();
  time_elapsed_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStats.time_elapsed)
}

// required double time_user = 2;
inline bool ServerStats::has_time_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerStats::set_has_time_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerStats::clear_has_time_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerStats::clear_time_user() {
  time_user_ = 0;
  clear_has_time_user();
}
inline double ServerStats::time_user() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStats.time_user)
  return time_user_;
}
inline void ServerStats::set_time_user(double value) {
  set_has_time_user();
  time_user_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStats.time_user)
}

// required double time_system = 3;
inline bool ServerStats::has_time_system() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerStats::set_has_time_system() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerStats::clear_has_time_system() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerStats::clear_time_system() {
  time_system_ = 0;
  clear_has_time_system();
}
inline double ServerStats::time_system() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStats.time_system)
  return time_system_;
}
inline void ServerStats::set_time_system(double value) {
  set_has_time_system();
  time_system_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStats.time_system)
}

// -------------------------------------------------------------------

// Payload

// optional .grpc.testing.PayloadType type = 1;
inline bool Payload::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Payload::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Payload::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Payload::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::grpc::testing::PayloadType Payload::type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.Payload.type)
  return static_cast< ::grpc::testing::PayloadType >(type_);
}
inline void Payload::set_type(::grpc::testing::PayloadType value) {
  assert(::grpc::testing::PayloadType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.Payload.type)
}

// optional bytes body = 2;
inline bool Payload::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Payload::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Payload::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Payload::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_body();
}
inline const ::std::string& Payload::body() const {
  // @@protoc_insertion_point(field_get:grpc.testing.Payload.body)
  return body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Payload::set_body(const ::std::string& value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.testing.Payload.body)
}
inline void Payload::set_body(const char* value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.testing.Payload.body)
}
inline void Payload::set_body(const void* value, size_t size) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.Payload.body)
}
inline ::std::string* Payload::mutable_body() {
  set_has_body();
  // @@protoc_insertion_point(field_mutable:grpc.testing.Payload.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Payload::release_body() {
  clear_has_body();
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Payload::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    set_has_body();
  } else {
    clear_has_body();
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.Payload.body)
}

// -------------------------------------------------------------------

// HistogramData

// repeated uint32 bucket = 1;
inline int HistogramData::bucket_size() const {
  return bucket_.size();
}
inline void HistogramData::clear_bucket() {
  bucket_.Clear();
}
inline ::google::protobuf::uint32 HistogramData::bucket(int index) const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.bucket)
  return bucket_.Get(index);
}
inline void HistogramData::set_bucket(int index, ::google::protobuf::uint32 value) {
  bucket_.Set(index, value);
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.bucket)
}
inline void HistogramData::add_bucket(::google::protobuf::uint32 value) {
  bucket_.Add(value);
  // @@protoc_insertion_point(field_add:grpc.testing.HistogramData.bucket)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HistogramData::bucket() const {
  // @@protoc_insertion_point(field_list:grpc.testing.HistogramData.bucket)
  return bucket_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HistogramData::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:grpc.testing.HistogramData.bucket)
  return &bucket_;
}

// required double min_seen = 2;
inline bool HistogramData::has_min_seen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistogramData::set_has_min_seen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistogramData::clear_has_min_seen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistogramData::clear_min_seen() {
  min_seen_ = 0;
  clear_has_min_seen();
}
inline double HistogramData::min_seen() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.min_seen)
  return min_seen_;
}
inline void HistogramData::set_min_seen(double value) {
  set_has_min_seen();
  min_seen_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.min_seen)
}

// required double max_seen = 3;
inline bool HistogramData::has_max_seen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistogramData::set_has_max_seen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistogramData::clear_has_max_seen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistogramData::clear_max_seen() {
  max_seen_ = 0;
  clear_has_max_seen();
}
inline double HistogramData::max_seen() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.max_seen)
  return max_seen_;
}
inline void HistogramData::set_max_seen(double value) {
  set_has_max_seen();
  max_seen_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.max_seen)
}

// required double sum = 4;
inline bool HistogramData::has_sum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistogramData::set_has_sum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistogramData::clear_has_sum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistogramData::clear_sum() {
  sum_ = 0;
  clear_has_sum();
}
inline double HistogramData::sum() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.sum)
  return sum_;
}
inline void HistogramData::set_sum(double value) {
  set_has_sum();
  sum_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.sum)
}

// required double sum_of_squares = 5;
inline bool HistogramData::has_sum_of_squares() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistogramData::set_has_sum_of_squares() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistogramData::clear_has_sum_of_squares() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistogramData::clear_sum_of_squares() {
  sum_of_squares_ = 0;
  clear_has_sum_of_squares();
}
inline double HistogramData::sum_of_squares() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.sum_of_squares)
  return sum_of_squares_;
}
inline void HistogramData::set_sum_of_squares(double value) {
  set_has_sum_of_squares();
  sum_of_squares_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.sum_of_squares)
}

// required double count = 6;
inline bool HistogramData::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistogramData::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistogramData::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistogramData::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline double HistogramData::count() const {
  // @@protoc_insertion_point(field_get:grpc.testing.HistogramData.count)
  return count_;
}
inline void HistogramData::set_count(double value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.HistogramData.count)
}

// -------------------------------------------------------------------

// ClientConfig

// repeated string server_targets = 1;
inline int ClientConfig::server_targets_size() const {
  return server_targets_.size();
}
inline void ClientConfig::clear_server_targets() {
  server_targets_.Clear();
}
inline const ::std::string& ClientConfig::server_targets(int index) const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.server_targets)
  return server_targets_.Get(index);
}
inline ::std::string* ClientConfig::mutable_server_targets(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientConfig.server_targets)
  return server_targets_.Mutable(index);
}
inline void ClientConfig::set_server_targets(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.server_targets)
  server_targets_.Mutable(index)->assign(value);
}
inline void ClientConfig::set_server_targets(int index, const char* value) {
  server_targets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.testing.ClientConfig.server_targets)
}
inline void ClientConfig::set_server_targets(int index, const char* value, size_t size) {
  server_targets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.ClientConfig.server_targets)
}
inline ::std::string* ClientConfig::add_server_targets() {
  return server_targets_.Add();
}
inline void ClientConfig::add_server_targets(const ::std::string& value) {
  server_targets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.testing.ClientConfig.server_targets)
}
inline void ClientConfig::add_server_targets(const char* value) {
  server_targets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.testing.ClientConfig.server_targets)
}
inline void ClientConfig::add_server_targets(const char* value, size_t size) {
  server_targets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.testing.ClientConfig.server_targets)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientConfig::server_targets() const {
  // @@protoc_insertion_point(field_list:grpc.testing.ClientConfig.server_targets)
  return server_targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientConfig::mutable_server_targets() {
  // @@protoc_insertion_point(field_mutable_list:grpc.testing.ClientConfig.server_targets)
  return &server_targets_;
}

// required .grpc.testing.ClientType client_type = 2;
inline bool ClientConfig::has_client_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientConfig::set_has_client_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientConfig::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientConfig::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::grpc::testing::ClientType ClientConfig::client_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.client_type)
  return static_cast< ::grpc::testing::ClientType >(client_type_);
}
inline void ClientConfig::set_client_type(::grpc::testing::ClientType value) {
  assert(::grpc::testing::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.client_type)
}

// optional bool enable_ssl = 3 [default = false];
inline bool ClientConfig::has_enable_ssl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientConfig::set_has_enable_ssl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientConfig::clear_has_enable_ssl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientConfig::clear_enable_ssl() {
  enable_ssl_ = false;
  clear_has_enable_ssl();
}
inline bool ClientConfig::enable_ssl() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.enable_ssl)
  return enable_ssl_;
}
inline void ClientConfig::set_enable_ssl(bool value) {
  set_has_enable_ssl();
  enable_ssl_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.enable_ssl)
}

// required int32 outstanding_rpcs_per_channel = 4;
inline bool ClientConfig::has_outstanding_rpcs_per_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientConfig::set_has_outstanding_rpcs_per_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientConfig::clear_has_outstanding_rpcs_per_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientConfig::clear_outstanding_rpcs_per_channel() {
  outstanding_rpcs_per_channel_ = 0;
  clear_has_outstanding_rpcs_per_channel();
}
inline ::google::protobuf::int32 ClientConfig::outstanding_rpcs_per_channel() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.outstanding_rpcs_per_channel)
  return outstanding_rpcs_per_channel_;
}
inline void ClientConfig::set_outstanding_rpcs_per_channel(::google::protobuf::int32 value) {
  set_has_outstanding_rpcs_per_channel();
  outstanding_rpcs_per_channel_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.outstanding_rpcs_per_channel)
}

// required int32 client_channels = 5;
inline bool ClientConfig::has_client_channels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientConfig::set_has_client_channels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientConfig::clear_has_client_channels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientConfig::clear_client_channels() {
  client_channels_ = 0;
  clear_has_client_channels();
}
inline ::google::protobuf::int32 ClientConfig::client_channels() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.client_channels)
  return client_channels_;
}
inline void ClientConfig::set_client_channels(::google::protobuf::int32 value) {
  set_has_client_channels();
  client_channels_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.client_channels)
}

// required int32 payload_size = 6;
inline bool ClientConfig::has_payload_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientConfig::set_has_payload_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientConfig::clear_has_payload_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientConfig::clear_payload_size() {
  payload_size_ = 0;
  clear_has_payload_size();
}
inline ::google::protobuf::int32 ClientConfig::payload_size() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.payload_size)
  return payload_size_;
}
inline void ClientConfig::set_payload_size(::google::protobuf::int32 value) {
  set_has_payload_size();
  payload_size_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.payload_size)
}

// optional int32 async_client_threads = 7;
inline bool ClientConfig::has_async_client_threads() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientConfig::set_has_async_client_threads() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientConfig::clear_has_async_client_threads() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientConfig::clear_async_client_threads() {
  async_client_threads_ = 0;
  clear_has_async_client_threads();
}
inline ::google::protobuf::int32 ClientConfig::async_client_threads() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.async_client_threads)
  return async_client_threads_;
}
inline void ClientConfig::set_async_client_threads(::google::protobuf::int32 value) {
  set_has_async_client_threads();
  async_client_threads_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.async_client_threads)
}

// optional .grpc.testing.RpcType rpc_type = 8 [default = UNARY];
inline bool ClientConfig::has_rpc_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientConfig::set_has_rpc_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientConfig::clear_has_rpc_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientConfig::clear_rpc_type() {
  rpc_type_ = 1;
  clear_has_rpc_type();
}
inline ::grpc::testing::RpcType ClientConfig::rpc_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.rpc_type)
  return static_cast< ::grpc::testing::RpcType >(rpc_type_);
}
inline void ClientConfig::set_rpc_type(::grpc::testing::RpcType value) {
  assert(::grpc::testing::RpcType_IsValid(value));
  set_has_rpc_type();
  rpc_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.rpc_type)
}

// optional string host = 9;
inline bool ClientConfig::has_host() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientConfig::set_has_host() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientConfig::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& ClientConfig::host() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientConfig.host)
  return host_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConfig::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.testing.ClientConfig.host)
}
inline void ClientConfig::set_host(const char* value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.testing.ClientConfig.host)
}
inline void ClientConfig::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.ClientConfig.host)
}
inline ::std::string* ClientConfig::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientConfig.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientConfig::release_host() {
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConfig::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientConfig.host)
}

// -------------------------------------------------------------------

// Mark

// -------------------------------------------------------------------

// ClientArgs

// optional .grpc.testing.ClientConfig setup = 1;
inline bool ClientArgs::has_setup() const {
  return argtype_case() == kSetup;
}
inline void ClientArgs::set_has_setup() {
  _oneof_case_[0] = kSetup;
}
inline void ClientArgs::clear_setup() {
  if (has_setup()) {
    delete argtype_.setup_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::ClientConfig& ClientArgs::setup() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientArgs.setup)
  return has_setup() ? *argtype_.setup_
                      : ::grpc::testing::ClientConfig::default_instance();
}
inline ::grpc::testing::ClientConfig* ClientArgs::mutable_setup() {
  if (!has_setup()) {
    clear_argtype();
    set_has_setup();
    argtype_.setup_ = new ::grpc::testing::ClientConfig;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientArgs.setup)
  return argtype_.setup_;
}
inline ::grpc::testing::ClientConfig* ClientArgs::release_setup() {
  if (has_setup()) {
    clear_has_argtype();
    ::grpc::testing::ClientConfig* temp = argtype_.setup_;
    argtype_.setup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientArgs::set_allocated_setup(::grpc::testing::ClientConfig* setup) {
  clear_argtype();
  if (setup) {
    set_has_setup();
    argtype_.setup_ = setup;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientArgs.setup)
}

// optional .grpc.testing.Mark mark = 2;
inline bool ClientArgs::has_mark() const {
  return argtype_case() == kMark;
}
inline void ClientArgs::set_has_mark() {
  _oneof_case_[0] = kMark;
}
inline void ClientArgs::clear_mark() {
  if (has_mark()) {
    delete argtype_.mark_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::Mark& ClientArgs::mark() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientArgs.mark)
  return has_mark() ? *argtype_.mark_
                      : ::grpc::testing::Mark::default_instance();
}
inline ::grpc::testing::Mark* ClientArgs::mutable_mark() {
  if (!has_mark()) {
    clear_argtype();
    set_has_mark();
    argtype_.mark_ = new ::grpc::testing::Mark;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientArgs.mark)
  return argtype_.mark_;
}
inline ::grpc::testing::Mark* ClientArgs::release_mark() {
  if (has_mark()) {
    clear_has_argtype();
    ::grpc::testing::Mark* temp = argtype_.mark_;
    argtype_.mark_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientArgs::set_allocated_mark(::grpc::testing::Mark* mark) {
  clear_argtype();
  if (mark) {
    set_has_mark();
    argtype_.mark_ = mark;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientArgs.mark)
}

inline bool ClientArgs::has_argtype() const {
  return argtype_case() != ARGTYPE_NOT_SET;
}
inline void ClientArgs::clear_has_argtype() {
  _oneof_case_[0] = ARGTYPE_NOT_SET;
}
inline ClientArgs::ArgtypeCase ClientArgs::argtype_case() const {
  return ClientArgs::ArgtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientStats

// required .grpc.testing.HistogramData latencies = 1;
inline bool ClientStats::has_latencies() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientStats::set_has_latencies() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientStats::clear_has_latencies() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientStats::clear_latencies() {
  if (latencies_ != NULL) latencies_->::grpc::testing::HistogramData::Clear();
  clear_has_latencies();
}
inline const ::grpc::testing::HistogramData& ClientStats::latencies() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.latencies)
  return latencies_ != NULL ? *latencies_ : *default_instance_->latencies_;
}
inline ::grpc::testing::HistogramData* ClientStats::mutable_latencies() {
  set_has_latencies();
  if (latencies_ == NULL) {
    latencies_ = new ::grpc::testing::HistogramData;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientStats.latencies)
  return latencies_;
}
inline ::grpc::testing::HistogramData* ClientStats::release_latencies() {
  clear_has_latencies();
  ::grpc::testing::HistogramData* temp = latencies_;
  latencies_ = NULL;
  return temp;
}
inline void ClientStats::set_allocated_latencies(::grpc::testing::HistogramData* latencies) {
  delete latencies_;
  latencies_ = latencies;
  if (latencies) {
    set_has_latencies();
  } else {
    clear_has_latencies();
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientStats.latencies)
}

// required double time_elapsed = 3;
inline bool ClientStats::has_time_elapsed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientStats::set_has_time_elapsed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientStats::clear_has_time_elapsed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientStats::clear_time_elapsed() {
  time_elapsed_ = 0;
  clear_has_time_elapsed();
}
inline double ClientStats::time_elapsed() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.time_elapsed)
  return time_elapsed_;
}
inline void ClientStats::set_time_elapsed(double value) {
  set_has_time_elapsed();
  time_elapsed_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientStats.time_elapsed)
}

// required double time_user = 4;
inline bool ClientStats::has_time_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientStats::set_has_time_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientStats::clear_has_time_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientStats::clear_time_user() {
  time_user_ = 0;
  clear_has_time_user();
}
inline double ClientStats::time_user() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.time_user)
  return time_user_;
}
inline void ClientStats::set_time_user(double value) {
  set_has_time_user();
  time_user_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientStats.time_user)
}

// required double time_system = 5;
inline bool ClientStats::has_time_system() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientStats::set_has_time_system() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientStats::clear_has_time_system() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientStats::clear_time_system() {
  time_system_ = 0;
  clear_has_time_system();
}
inline double ClientStats::time_system() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStats.time_system)
  return time_system_;
}
inline void ClientStats::set_time_system(double value) {
  set_has_time_system();
  time_system_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ClientStats.time_system)
}

// -------------------------------------------------------------------

// ClientStatus

// optional .grpc.testing.ClientStats stats = 1;
inline bool ClientStatus::has_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientStatus::set_has_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientStatus::clear_has_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientStatus::clear_stats() {
  if (stats_ != NULL) stats_->::grpc::testing::ClientStats::Clear();
  clear_has_stats();
}
inline const ::grpc::testing::ClientStats& ClientStatus::stats() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ClientStatus.stats)
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::grpc::testing::ClientStats* ClientStatus::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) {
    stats_ = new ::grpc::testing::ClientStats;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ClientStatus.stats)
  return stats_;
}
inline ::grpc::testing::ClientStats* ClientStatus::release_stats() {
  clear_has_stats();
  ::grpc::testing::ClientStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void ClientStatus::set_allocated_stats(::grpc::testing::ClientStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ClientStatus.stats)
}

// -------------------------------------------------------------------

// ServerConfig

// required .grpc.testing.ServerType server_type = 1;
inline bool ServerConfig::has_server_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerConfig::set_has_server_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerConfig::clear_has_server_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerConfig::clear_server_type() {
  server_type_ = 1;
  clear_has_server_type();
}
inline ::grpc::testing::ServerType ServerConfig::server_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.server_type)
  return static_cast< ::grpc::testing::ServerType >(server_type_);
}
inline void ServerConfig::set_server_type(::grpc::testing::ServerType value) {
  assert(::grpc::testing::ServerType_IsValid(value));
  set_has_server_type();
  server_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.server_type)
}

// optional int32 threads = 2 [default = 1];
inline bool ServerConfig::has_threads() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerConfig::set_has_threads() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerConfig::clear_has_threads() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerConfig::clear_threads() {
  threads_ = 1;
  clear_has_threads();
}
inline ::google::protobuf::int32 ServerConfig::threads() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.threads)
  return threads_;
}
inline void ServerConfig::set_threads(::google::protobuf::int32 value) {
  set_has_threads();
  threads_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.threads)
}

// optional bool enable_ssl = 3 [default = false];
inline bool ServerConfig::has_enable_ssl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerConfig::set_has_enable_ssl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerConfig::clear_has_enable_ssl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerConfig::clear_enable_ssl() {
  enable_ssl_ = false;
  clear_has_enable_ssl();
}
inline bool ServerConfig::enable_ssl() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.enable_ssl)
  return enable_ssl_;
}
inline void ServerConfig::set_enable_ssl(bool value) {
  set_has_enable_ssl();
  enable_ssl_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.enable_ssl)
}

// optional string host = 4;
inline bool ServerConfig::has_host() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerConfig::set_has_host() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerConfig::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& ServerConfig::host() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerConfig.host)
  return host_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerConfig::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.testing.ServerConfig.host)
}
inline void ServerConfig::set_host(const char* value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.testing.ServerConfig.host)
}
inline void ServerConfig::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.testing.ServerConfig.host)
}
inline ::std::string* ServerConfig::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerConfig.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerConfig::release_host() {
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerConfig::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerConfig.host)
}

// -------------------------------------------------------------------

// ServerArgs

// optional .grpc.testing.ServerConfig setup = 1;
inline bool ServerArgs::has_setup() const {
  return argtype_case() == kSetup;
}
inline void ServerArgs::set_has_setup() {
  _oneof_case_[0] = kSetup;
}
inline void ServerArgs::clear_setup() {
  if (has_setup()) {
    delete argtype_.setup_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::ServerConfig& ServerArgs::setup() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerArgs.setup)
  return has_setup() ? *argtype_.setup_
                      : ::grpc::testing::ServerConfig::default_instance();
}
inline ::grpc::testing::ServerConfig* ServerArgs::mutable_setup() {
  if (!has_setup()) {
    clear_argtype();
    set_has_setup();
    argtype_.setup_ = new ::grpc::testing::ServerConfig;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerArgs.setup)
  return argtype_.setup_;
}
inline ::grpc::testing::ServerConfig* ServerArgs::release_setup() {
  if (has_setup()) {
    clear_has_argtype();
    ::grpc::testing::ServerConfig* temp = argtype_.setup_;
    argtype_.setup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerArgs::set_allocated_setup(::grpc::testing::ServerConfig* setup) {
  clear_argtype();
  if (setup) {
    set_has_setup();
    argtype_.setup_ = setup;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerArgs.setup)
}

// optional .grpc.testing.Mark mark = 2;
inline bool ServerArgs::has_mark() const {
  return argtype_case() == kMark;
}
inline void ServerArgs::set_has_mark() {
  _oneof_case_[0] = kMark;
}
inline void ServerArgs::clear_mark() {
  if (has_mark()) {
    delete argtype_.mark_;
    clear_has_argtype();
  }
}
inline const ::grpc::testing::Mark& ServerArgs::mark() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerArgs.mark)
  return has_mark() ? *argtype_.mark_
                      : ::grpc::testing::Mark::default_instance();
}
inline ::grpc::testing::Mark* ServerArgs::mutable_mark() {
  if (!has_mark()) {
    clear_argtype();
    set_has_mark();
    argtype_.mark_ = new ::grpc::testing::Mark;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerArgs.mark)
  return argtype_.mark_;
}
inline ::grpc::testing::Mark* ServerArgs::release_mark() {
  if (has_mark()) {
    clear_has_argtype();
    ::grpc::testing::Mark* temp = argtype_.mark_;
    argtype_.mark_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerArgs::set_allocated_mark(::grpc::testing::Mark* mark) {
  clear_argtype();
  if (mark) {
    set_has_mark();
    argtype_.mark_ = mark;
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerArgs.mark)
}

inline bool ServerArgs::has_argtype() const {
  return argtype_case() != ARGTYPE_NOT_SET;
}
inline void ServerArgs::clear_has_argtype() {
  _oneof_case_[0] = ARGTYPE_NOT_SET;
}
inline ServerArgs::ArgtypeCase ServerArgs::argtype_case() const {
  return ServerArgs::ArgtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerStatus

// optional .grpc.testing.ServerStats stats = 1;
inline bool ServerStatus::has_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStatus::set_has_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStatus::clear_has_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStatus::clear_stats() {
  if (stats_ != NULL) stats_->::grpc::testing::ServerStats::Clear();
  clear_has_stats();
}
inline const ::grpc::testing::ServerStats& ServerStatus::stats() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStatus.stats)
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::grpc::testing::ServerStats* ServerStatus::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) {
    stats_ = new ::grpc::testing::ServerStats;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.ServerStatus.stats)
  return stats_;
}
inline ::grpc::testing::ServerStats* ServerStatus::release_stats() {
  clear_has_stats();
  ::grpc::testing::ServerStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void ServerStatus::set_allocated_stats(::grpc::testing::ServerStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.ServerStatus.stats)
}

// required int32 port = 2;
inline bool ServerStatus::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerStatus::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerStatus::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerStatus::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ServerStatus::port() const {
  // @@protoc_insertion_point(field_get:grpc.testing.ServerStatus.port)
  return port_;
}
inline void ServerStatus::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.ServerStatus.port)
}

// -------------------------------------------------------------------

// SimpleRequest

// optional .grpc.testing.PayloadType response_type = 1 [default = COMPRESSABLE];
inline bool SimpleRequest::has_response_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleRequest::set_has_response_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleRequest::clear_has_response_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleRequest::clear_response_type() {
  response_type_ = 1;
  clear_has_response_type();
}
inline ::grpc::testing::PayloadType SimpleRequest::response_type() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleRequest.response_type)
  return static_cast< ::grpc::testing::PayloadType >(response_type_);
}
inline void SimpleRequest::set_response_type(::grpc::testing::PayloadType value) {
  assert(::grpc::testing::PayloadType_IsValid(value));
  set_has_response_type();
  response_type_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.SimpleRequest.response_type)
}

// optional int32 response_size = 2 [default = 0];
inline bool SimpleRequest::has_response_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimpleRequest::set_has_response_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimpleRequest::clear_has_response_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimpleRequest::clear_response_size() {
  response_size_ = 0;
  clear_has_response_size();
}
inline ::google::protobuf::int32 SimpleRequest::response_size() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleRequest.response_size)
  return response_size_;
}
inline void SimpleRequest::set_response_size(::google::protobuf::int32 value) {
  set_has_response_size();
  response_size_ = value;
  // @@protoc_insertion_point(field_set:grpc.testing.SimpleRequest.response_size)
}

// optional .grpc.testing.Payload payload = 3;
inline bool SimpleRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimpleRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimpleRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimpleRequest::clear_payload() {
  if (payload_ != NULL) payload_->::grpc::testing::Payload::Clear();
  clear_has_payload();
}
inline const ::grpc::testing::Payload& SimpleRequest::payload() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleRequest.payload)
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
}
inline ::grpc::testing::Payload* SimpleRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == NULL) {
    payload_ = new ::grpc::testing::Payload;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.SimpleRequest.payload)
  return payload_;
}
inline ::grpc::testing::Payload* SimpleRequest::release_payload() {
  clear_has_payload();
  ::grpc::testing::Payload* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void SimpleRequest::set_allocated_payload(::grpc::testing::Payload* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.SimpleRequest.payload)
}

// -------------------------------------------------------------------

// SimpleResponse

// optional .grpc.testing.Payload payload = 1;
inline bool SimpleResponse::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleResponse::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleResponse::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleResponse::clear_payload() {
  if (payload_ != NULL) payload_->::grpc::testing::Payload::Clear();
  clear_has_payload();
}
inline const ::grpc::testing::Payload& SimpleResponse::payload() const {
  // @@protoc_insertion_point(field_get:grpc.testing.SimpleResponse.payload)
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
}
inline ::grpc::testing::Payload* SimpleResponse::mutable_payload() {
  set_has_payload();
  if (payload_ == NULL) {
    payload_ = new ::grpc::testing::Payload;
  }
  // @@protoc_insertion_point(field_mutable:grpc.testing.SimpleResponse.payload)
  return payload_;
}
inline ::grpc::testing::Payload* SimpleResponse::release_payload() {
  clear_has_payload();
  ::grpc::testing::Payload* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void SimpleResponse::set_allocated_payload(::grpc::testing::Payload* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  // @@protoc_insertion_point(field_set_allocated:grpc.testing.SimpleResponse.payload)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace testing
}  // namespace grpc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::grpc::testing::PayloadType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::PayloadType>() {
  return ::grpc::testing::PayloadType_descriptor();
}
template <> struct is_proto_enum< ::grpc::testing::ClientType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::ClientType>() {
  return ::grpc::testing::ClientType_descriptor();
}
template <> struct is_proto_enum< ::grpc::testing::ServerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::ServerType>() {
  return ::grpc::testing::ServerType_descriptor();
}
template <> struct is_proto_enum< ::grpc::testing::RpcType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::testing::RpcType>() {
  return ::grpc::testing::RpcType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_qpstest_2eproto__INCLUDED
